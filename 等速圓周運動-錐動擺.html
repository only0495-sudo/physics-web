<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>錐動單擺 (最終完美版)</title>
    <style>
        /* --- 基礎設定 --- */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background-color: #f0f2f5; 
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif; 
        }

        /* --- 左上角：數學公式 (直式分數) --- */
        #math-panel {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px; border-radius: 8px;
            border-left: 5px solid #2e7d32;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            pointer-events: none;
        }
        .math-row { 
            display: flex; align-items: center; margin-bottom: 12px; 
            font-size: 18px; color: #333; 
        }
        .math-eq { 
            font-family: "Times New Roman", serif; font-style: italic; font-weight: bold; 
            margin-left: 10px; display: flex; align-items: center;
        }
        .fraction { 
            display: inline-flex; flex-direction: column; align-items: center; 
            vertical-align: middle; margin: 0 5px; font-size: 0.9em; 
        }
        .numerator { 
            border-bottom: 2px solid #000; padding: 0 2px; display: block; 
            text-align: center; width: 100%;
        }
        .denominator { 
            padding: 0 2px; display: block; 
            text-align: center; width: 100%;
        }

        /* --- 左下角：FBD 受力分析圖 --- */
        #fbd-container {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 320px; 
            height: 390px; /* 稍微加高以容納註記 */
            overflow: hidden;
            border: 1px solid #ccc;
        }
        #fbd-header {
            background: #e3f2fd; color: #1565c0;
            padding: 10px; font-size: 16px; font-weight: bold;
            text-align: center; border-bottom: 1px solid #bbdefb;
        }
        /* 新增：FBD 註記樣式 */
        .fbd-note {
            background-color: #fff8e1; /* 淡黃色背景 */
            color: #ef6c00;            /* 深橘色文字 */
            font-size: 12px;
            padding: 6px 10px;
            text-align: center;
            border-bottom: 1px solid #ffe0b2;
            line-height: 1.4;
        }

        #fbd-canvas { display: block; background: #fff; margin: 0 auto; }

        /* --- 右側：控制面板 --- */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            width: 300px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: flex; flex-direction: column;
            overflow: hidden;
            font-family: "Microsoft JhengHei", sans-serif;
        }

        .panel-header {
            background: #e3f2fd; color: #0d47a1;
            padding: 12px 15px;
            font-size: 18px; font-weight: bold;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #bbdefb;
        }

        .panel-content { padding: 15px; }

        .btn {
            width: 100%; border: none; border-radius: 6px;
            padding: 10px; font-size: 16px; font-weight: bold;
            cursor: pointer; margin-bottom: 10px; color: #fff;
            transition: opacity 0.2s;
        }
        .btn:hover { opacity: 0.9; }
        .btn-reset { background-color: #c62828; }
        .btn-pause { background-color: #5c6bc0; }
        .btn-pause.paused { background-color: #ff9800; }

        .control-group { margin-bottom: 15px; }
        .control-label {
            font-size: 14px; font-weight: bold; color: #333;
            margin-bottom: 8px; display: flex; justify-content: space-between;
        }
        input[type=range] {
            width: 100%; cursor: pointer; height: 6px; background: #ddd;
            border-radius: 3px; outline: none; -webkit-appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            border-radius: 50%; background: #1976d2; cursor: pointer;
            border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .data-display {
            border-top: 1px solid #eee; margin-top: 10px; padding-top: 10px;
        }
        .data-row {
            display: flex; justify-content: space-between;
            font-size: 14px; margin-bottom: 6px; color: #555;
        }
        .data-val { font-weight: bold; color: #d32f2f; font-family: monospace; font-size: 15px;}

        .legend-box {
            background: #f9f9f9; border-radius: 6px; padding: 10px;
            margin-top: 10px; border: 1px solid #eee;
        }
        .legend-item {
            display: flex; align-items: center; font-size: 13px; color: #444; margin-bottom: 4px;
        }
        .color-box { width: 12px; height: 12px; border-radius: 2px; margin-right: 8px; }

        /* 3D 標籤 */
        .force-label {
            background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; 
            color: #000; padding: 2px 5px; border-radius: 3px;
            font-size: 12px; font-weight: bold; pointer-events: none;
        }
        .angle-label { color: #ff8f00; font-weight: bold; font-size: 18px; text-shadow: 1px 1px 0 #fff; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>
<body>

    <div id="math-panel">
        <div class="math-row">
            <span>水平合力:</span> 
            <span class="math-eq">
                Fc = T sin&theta; = m 
                <div class="fraction">
                    <span class="numerator">v²</span>
                    <span class="denominator">r</span>
                </div>
            </span>
        </div>
        <div class="math-row">
            <span>垂直平衡:</span> 
            <span class="math-eq">T cos&theta; = mg</span>
        </div>
    </div>

    <div id="fbd-container">
        <div id="fbd-header">受力分析 (FBD)</div>
        <div class="fbd-note">
            ⚠️ 為了向量的可視性，<br>原本不變的 mg 會有所伸縮為正常現象
        </div>
        <canvas id="fbd-canvas" width="320" height="320"></canvas>
    </div>

    <div id="ui-panel">
        <div class="panel-header">
            參數設定
            <span style="font-size: 12px; cursor: pointer;">收起 ▲</span>
        </div>
        <div class="panel-content">
            <button class="btn btn-reset" onclick="resetSim()">重置 (Reset)</button>
            <button class="btn btn-pause" id="btn-pause" onclick="togglePause()">暫停 / 繼續 (Pause)</button>

            <div class="control-group">
                <div class="control-label">
                    切線速率 v (m/s)
                    <span id="val-velocity">10.0</span>
                </div>
                <input type="range" id="input-velocity" min="0" max="22" step="0.1" value="10">
            </div>

            <div class="data-display">
                <div class="data-row">
                    <span>擺角 (&theta;):</span>
                    <span class="data-val" id="disp-theta">0.0°</span>
                </div>
                <div class="data-row">
                    <span>繩張力 (T):</span>
                    <span class="data-val" id="disp-tension">-- N</span>
                </div>
                <div class="data-row">
                    <span>向心力 (Fc):</span>
                    <span class="data-val" id="disp-fc">-- N</span>
                </div>
            </div>

            <div class="legend-box">
                <div class="legend-item"><div class="color-box" style="background:#d32f2f;"></div> Fc (向心力 / 合力)</div>
                <div class="legend-item"><div class="color-box" style="background:#1565c0;"></div> T (繩張力)</div>
                <div class="legend-item"><div class="color-box" style="background:#2e7d32;"></div> mg (重力)</div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. 全局變數 ---
        let scene, camera, renderer, labelRenderer, controls;
        let mainGroup, arrows = {}, labels = {};
        let objects = {};
        
        const POLE_HEIGHT = 40;
        const STRING_LEN = 30;
        const MASS = 10; 

        let params = {
            velocity: 10.0,
            paused: false,
            theta: 0,
            time: 0
        };

        const uiVelocity = document.getElementById('input-velocity');
        const uiValVelocity = document.getElementById('val-velocity');
        const dispTheta = document.getElementById('disp-theta');
        const dispTension = document.getElementById('disp-tension');
        const dispFc = document.getElementById('disp-fc');
        const fbdCanvas = document.getElementById('fbd-canvas');
        const fbdCtx = fbdCanvas.getContext('2d');

        // --- 2. 初始化 ---
        window.onload = init;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5); 
            scene.fog = new THREE.Fog(0xf0f2f5, 50, 300);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 90);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 20, 0);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);
            scene.add(new THREE.GridHelper(300, 60, 0xdddddd, 0xeeeeee));

            createSceneObjects();

            uiVelocity.addEventListener('input', (e) => {
                params.velocity = parseFloat(e.target.value);
                uiValVelocity.innerText = params.velocity.toFixed(1);
            });

            animate();
            window.addEventListener('resize', onWindowResize);
        }

        // --- 3. 建立物件 ---
        function createSceneObjects() {
            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // 虛線軸
            const dashGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, POLE_HEIGHT, 0),
                new THREE.Vector3(0, 0, 0)
            ]);
            const dashMat = new THREE.LineDashedMaterial({ color: 0x888888, dashSize: 1.5, gapSize: 1.5 });
            objects.axisLine = new THREE.Line(dashGeo, dashMat);
            objects.axisLine.computeLineDistances();
            mainGroup.add(objects.axisLine);

            // 頂板
            const topGeo = new THREE.CylinderGeometry(2, 2, 0.5, 32);
            objects.topPlate = new THREE.Mesh(topGeo, new THREE.MeshStandardMaterial({color: 0x333}));
            objects.topPlate.position.y = POLE_HEIGHT;
            mainGroup.add(objects.topPlate);

            // 擺錘
            objects.bob = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.MeshStandardMaterial({color: 0xffaa00}) 
            );
            objects.bob.castShadow = true;
            mainGroup.add(objects.bob);

            // 繩子
            const stringGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, POLE_HEIGHT, 0), new THREE.Vector3(0,0,0)]);
            objects.string = new THREE.Line(stringGeo, new THREE.LineBasicMaterial({color: 0x222, linewidth: 2}));
            mainGroup.add(objects.string);

            // 角度弧線 (Arc)
            objects.arcLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xff8f00, linewidth: 2 }));
            mainGroup.add(objects.arcLine);

            // 角度標籤
            const divAngle = document.createElement('div');
            divAngle.className = 'angle-label'; divAngle.innerText = "θ";
            labels.theta = new THREE.CSS2DObject(divAngle);
            scene.add(labels.theta);

            // 3D 箭頭
            createArrow('mg', 0x2e7d32, 'mg'); 
            createArrow('T', 0x1565c0, 'T');   
            createArrow('Fc', 0xd32f2f, 'Fc'); 
        }

        function createArrow(name, color, text) {
            const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(), 5, color, 2, 1);
            mainGroup.add(arrow);
            arrows[name] = arrow;

            const div = document.createElement('div');
            div.className = 'force-label'; div.innerText = text;
            div.style.borderColor = '#' + color.toString(16).padStart(6,'0');
            div.style.color = '#' + color.toString(16).padStart(6,'0');
            labels[name] = new THREE.CSS2DObject(div);
            scene.add(labels[name]);
        }

        // --- 4. 動畫核心 ---
        function animate() {
            requestAnimationFrame(animate);
            if (!params.paused) {
                updatePhysics();
            }
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function updatePhysics() {
            const dt = 0.016;
            const v = params.velocity;
            
            // 物理模擬角度 (近似)
            let theta = (v / 20) * 1.4; 
            if(theta > 1.45) theta = 1.45;
            params.theta = theta;

            const r = STRING_LEN * Math.sin(theta);
            const h = STRING_LEN * Math.cos(theta);
            const radius = Math.max(0.1, r);

            params.time -= (v / radius) * dt; 
            const x = radius * Math.cos(params.time);
            const z = radius * Math.sin(params.time);
            const y = POLE_HEIGHT - h;

            // 3D 物件更新
            objects.bob.position.set(x, y, z);
            objects.string.geometry.attributes.position.setXYZ(1, x, y, z);
            objects.string.geometry.attributes.position.needsUpdate = true;
            updateAngleVisuals(theta, x, z);

            // 3D 箭頭更新
            const bobPos = objects.bob.position;
            const pivotPos = new THREE.Vector3(0, POLE_HEIGHT, 0);
            updateArrow('mg', bobPos, new THREE.Vector3(0, -1, 0), 8);
            const dirT = new THREE.Vector3().subVectors(pivotPos, bobPos).normalize();
            updateArrow('T', bobPos, dirT, 8 / Math.cos(theta)); 
            const dirFc = new THREE.Vector3().subVectors(new THREE.Vector3(0, y, 0), bobPos).normalize();
            updateArrow('Fc', bobPos, dirFc, 8 * Math.tan(theta));

            // 面板數據更新
            const tensionVal = (MASS * 9.8) / Math.cos(theta);
            const fcVal = tensionVal * Math.sin(theta);
            dispTheta.innerText = (theta * 180 / Math.PI).toFixed(1) + "°";
            dispTension.innerText = tensionVal.toFixed(0) + " N";
            dispFc.innerText = fcVal.toFixed(0) + " N";

            // 繪製 FBD (連動)
            drawDynamicFBD(theta);
        }

        function updateAngleVisuals(theta, bobX, bobZ) {
            const radius = 8;
            const segments = 16;
            const points = [];
            const pivot = new THREE.Vector3(0, POLE_HEIGHT, 0);
            const currentDir = new THREE.Vector3(bobX, -STRING_LEN * Math.cos(theta), bobZ).normalize();
            const downDir = new THREE.Vector3(0, -1, 0);

            for (let i = 0; i <= segments; i++) {
                const t = i / segments; 
                const vec = new THREE.Vector3().copy(downDir).lerp(currentDir, t).normalize().multiplyScalar(radius);
                points.push(new THREE.Vector3().addVectors(pivot, vec));
            }
            objects.arcLine.geometry.setFromPoints(points);
            
            const midVec = new THREE.Vector3().copy(downDir).lerp(currentDir, 0.5).normalize().multiplyScalar(radius + 4);
            labels.theta.position.copy(pivot.clone().add(midVec));
        }

        function updateArrow(name, pos, dir, len) {
            const arr = arrows[name];
            const lbl = labels[name];
            if(arr) {
                arr.position.copy(pos);
                arr.setDirection(dir);
                arr.setLength(Math.max(1, len));
                lbl.position.copy(dir.clone().multiplyScalar(len + 2).add(pos));
            }
        }

        // --- 5. FBD 繪圖 (智慧縮放版) ---
        function drawDynamicFBD(theta) {
            const ctx = fbdCtx;
            const W = fbdCanvas.width;
            const H = fbdCanvas.height;
            const CX = W / 2;
            const CY = H / 2 + 30; 

            ctx.clearRect(0, 0, W, H);

            // 1. 計算理論像素長度
            const baseLenMG = 80; 
            let lenT = baseLenMG / Math.cos(theta);
            let lenFc = baseLenMG * Math.tan(theta);

            // 2. 計算邊界限制 (Smart Scaling Logic)
            const maxRadius = Math.min(W, H) / 2 - 20; 
            const maxVectorLen = Math.max(baseLenMG, lenT, lenFc);
            
            let scale = 1;
            if (maxVectorLen > maxRadius) {
                scale = maxRadius / maxVectorLen;
            }

            const drawLenMG = baseLenMG * scale;
            const drawLenT = lenT * scale;
            const drawLenFc = lenFc * scale;

            // 3. 繪製座標軸
            ctx.beginPath();
            ctx.strokeStyle = '#e0e0e0';
            ctx.setLineDash([5, 5]);
            ctx.moveTo(CX, 0); ctx.lineTo(CX, H);
            ctx.moveTo(0, CY); ctx.lineTo(W, CY);
            ctx.stroke();
            ctx.setLineDash([]);

            // 4. 繪製物體
            const boxSize = 24;
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(CX - boxSize/2, CY - boxSize/2, boxSize, boxSize);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(CX - boxSize/2, CY - boxSize/2, boxSize, boxSize);

            // 5. 繪製向量
            drawVector(ctx, CX, CY, 0, drawLenMG, '#2e7d32', 'mg');
            
            const tx = -Math.sin(theta) * drawLenT;
            const ty = -Math.cos(theta) * drawLenT;
            drawVector(ctx, CX, CY, tx, ty, '#1565c0', 'T');
            
            drawVector(ctx, CX, CY, -drawLenFc, 0, '#d32f2f', 'Fc');

            // 6. 繪製角度
            const rArc = 40 * scale; 
            const actualRArc = Math.max(25, Math.min(rArc, 50)); 
            ctx.beginPath();
            ctx.strokeStyle = '#ff8f00';
            ctx.lineWidth = 2;
            ctx.arc(CX, CY, actualRArc, -Math.PI/2 - theta, -Math.PI/2);
            ctx.stroke();
            
            ctx.fillStyle = '#ff8f00';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText("θ", CX - 10, CY - actualRArc - 5);
        }

        function drawVector(ctx, x, y, dx, dy, color, label) {
            ctx.beginPath();
            ctx.lineWidth = 3;
            ctx.strokeStyle = color;
            ctx.moveTo(x, y);
            ctx.lineTo(x + dx, y + dy);
            ctx.stroke();

            const angle = Math.atan2(dy, dx);
            const headLen = 10;
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(x + dx, y + dy);
            ctx.lineTo(x + dx - headLen * Math.cos(angle - Math.PI/6), y + dy - headLen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x + dx - headLen * Math.cos(angle + Math.PI/6), y + dy - headLen * Math.sin(angle + Math.PI/6));
            ctx.fill();

            ctx.font = "bold 15px Arial";
            ctx.fillStyle = color;
            let textX = x + dx;
            let textY = y + dy;
            
            if (dx > 0) textX += 8; else textX -= 25;
            if (dy > 0) textY += 20; else textY -= 8;
            
            ctx.fillText(label, textX, textY);
        }

        function togglePause() {
            params.paused = !params.paused;
            const btn = document.getElementById('btn-pause');
            if(params.paused) {
                btn.innerText = "繼續 (Resume)";
                btn.classList.add('paused');
            } else {
                btn.innerText = "暫停 / 繼續 (Pause)";
                btn.classList.remove('paused');
            }
        }

        function resetSim() {
            params.velocity = 10.0;
            uiVelocity.value = 10.0;
            uiValVelocity.innerText = "10.0";
            params.theta = 0;
            params.time = 0;
            if(params.paused) togglePause();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>