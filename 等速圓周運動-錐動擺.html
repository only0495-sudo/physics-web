\<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>錐動單擺 (質量調整最終版)</title>
    <style>
        /* --- 基礎設定 --- */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background-color: #f0f2f5; 
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif; 
            overscroll-behavior: none;
        }

        /* --- 左上角：數學公式 --- */
        #math-panel {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px; border-radius: 8px;
            border-left: 5px solid #2e7d32;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            pointer-events: none;
            transform-origin: top left; 
            transition: all 0.3s ease;
        }
        .math-row { 
            display: flex; align-items: center; margin-bottom: 8px; 
            font-size: 16px; color: #333; 
        }
        .math-eq { 
            font-family: "Times New Roman", serif; font-style: italic; font-weight: bold; 
            margin-left: 10px; display: flex; align-items: center;
        }
        .fraction { 
            display: inline-flex; flex-direction: column; align-items: center; 
            vertical-align: middle; margin: 0 5px; font-size: 0.9em; 
        }
        .numerator { 
            border-bottom: 2px solid #000; padding: 0 2px; display: block; 
            text-align: center; width: 100%;
        }
        .denominator { 
            padding: 0 2px; display: block; 
            text-align: center; width: 100%;
        }

        /* --- FBD 受力分析圖 --- */
        #fbd-container {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 300px; 
            height: 250px;
            overflow: hidden;
            border: 1px solid #ccc;
            transition: all 0.3s ease;
            transform-origin: bottom left;
        }
        #fbd-header {
            background: #e3f2fd; color: #1565c0;
            padding: 8px 10px; font-size: 15px; font-weight: bold;
            text-align: center; border-bottom: 1px solid #bbdefb;
            cursor: pointer; 
            display: flex; justify-content: space-between; align-items: center;
        }
        #fbd-toggle-icon { font-size: 12px; }
        .fbd-note {
            background-color: #fff8e1; color: #ef6c00; font-size: 11px;
            padding: 4px 8px; text-align: center;
            border-bottom: 1px solid #ffe0b2; line-height: 1.3;
        }
        #fbd-content-wrapper {
            transition: height 0.3s ease;
            overflow: hidden;
            height: 100%; 
        }
        #fbd-canvas { display: block; background: #fff; margin: 0 auto; }

        /* --- 右側：控制面板 --- */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            width: 300px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: flex; flex-direction: column;
            font-family: "Microsoft JhengHei", sans-serif;
            transition: all 0.3s ease;
            max-height: 90vh;
        }

        .panel-header {
            background: #e3f2fd; color: #0d47a1;
            padding: 12px 15px;
            font-size: 18px; font-weight: bold;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #bbdefb;
            cursor: pointer; 
        }

        .panel-content { 
            padding: 15px; 
            overflow-y: auto; 
            transition: max-height 0.3s ease;
        }
        .collapsed .panel-content { display: none; }
        .collapsed #fbd-content-wrapper { display: none; }
        #fbd-container.collapsed { height: auto; }

        .btn {
            width: 100%; border: none; border-radius: 6px;
            padding: 12px; font-size: 16px; font-weight: bold;
            cursor: pointer; margin-bottom: 10px; color: #fff;
            transition: opacity 0.2s;
        }
        .btn:hover { opacity: 0.9; }
        .btn-reset { background-color: #c62828; }
        .btn-pause { background-color: #5c6bc0; }
        .btn-pause.paused { background-color: #ff9800; }

        .control-group { margin-bottom: 15px; }
        .control-label {
            font-size: 14px; font-weight: bold; color: #333;
            margin-bottom: 8px; display: flex; justify-content: space-between;
        }
        input[type=range] {
            width: 100%; cursor: pointer; height: 8px; background: #ddd;
            border-radius: 4px; outline: none; -webkit-appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 24px; height: 24px;
            border-radius: 50%; background: #1976d2; cursor: pointer;
            border: 3px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .data-display {
            border-top: 1px solid #eee; margin-top: 10px; padding-top: 10px;
        }
        .data-row {
            display: flex; justify-content: space-between;
            font-size: 14px; margin-bottom: 6px; color: #555;
        }
        .data-val { font-weight: bold; color: #d32f2f; font-family: monospace; font-size: 15px;}

        .legend-box {
            background: #f9f9f9; border-radius: 6px; padding: 10px;
            margin-top: 10px; border: 1px solid #eee;
        }
        .legend-item {
            display: flex; align-items: center; font-size: 13px; color: #444; margin-bottom: 4px;
        }
        .color-box { width: 12px; height: 12px; border-radius: 2px; margin-right: 8px; }

        /* 3D 標籤樣式 */
        .force-label {
            background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; 
            color: #000; padding: 2px 5px; border-radius: 3px;
            font-size: 12px; font-weight: bold; pointer-events: none;
        }
        .angle-label { color: #ff8f00; font-weight: bold; font-size: 18px; text-shadow: 1px 1px 0 #fff; }
        .geo-label {
            color: #444; font-family: "Times New Roman", serif; font-style: italic;
            font-size: 16px; font-weight: bold; text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
            pointer-events: none;
        }

        /* RWD: 手機版樣式 */
        @media (max-width: 850px) {
            #ui-panel {
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%; 
                border-radius: 20px 20px 0 0; 
                box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
                max-height: 60vh; 
            }
            .panel-header { padding: 15px; justify-content: center; }
            .panel-header::before {
                content: ""; position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
                width: 40px; height: 4px; background: #bbdefb; border-radius: 2px;
            }
            .panel-content { padding-bottom: 30px; }

            #fbd-container {
                left: auto; right: 10px; 
                bottom: auto; top: 70px; 
                width: 300px; 
                transform: scale(0.65); 
                transform-origin: top right; 
            }
            #math-panel {
                top: 10px; left: 10px;
                transform: scale(0.75);
            }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>
<body>

    <div id="math-panel">
        <div class="math-row">
            <span>旋轉半徑:</span> 
            <span class="math-eq">r = L sin&theta;</span>
        </div>
        <div class="math-row">
            <span>水平合力:</span> 
            <span class="math-eq">
                Fc = T sin&theta; = m 
                <div class="fraction">
                    <span class="numerator">v²</span>
                    <span class="denominator">r</span>
                </div>
            </span>
        </div>
        <div class="math-row">
            <span>垂直平衡:</span> 
            <span class="math-eq">T cos&theta; = mg</span>
        </div>
    </div>

    <div id="fbd-container">
        <div id="fbd-header" onclick="toggleFBD()">
            受力分析 (FBD)
            <span id="fbd-toggle-icon">▼</span>
        </div>
        <div id="fbd-content-wrapper">
            <div class="fbd-note">
                ⚠️ 向量縮放顯示以適應畫面
            </div>
            <canvas id="fbd-canvas" width="300" height="180"></canvas>
        </div>
    </div>

    <div id="ui-panel">
        <div class="panel-header" onclick="togglePanel()">
            參數設定
            <span id="panel-toggle-icon" style="font-size: 12px; margin-left: 10px;">▼</span>
        </div>
        <div class="panel-content">
            <button class="btn btn-reset" onclick="resetSim()">重置 (Reset)</button>
            <button class="btn btn-pause" id="btn-pause" onclick="togglePause()">暫停 / 繼續 (Pause)</button>

            <div class="control-group">
                <div class="control-label">
                    切線速率 v (m/s)
                    <span id="val-velocity">10.0</span>
                </div>
                <input type="range" id="input-velocity" min="0" max="22" step="0.1" value="10">
            </div>

            <div class="control-group">
                <div class="control-label">
                    擺錘質量 m (kg)
                    <span id="val-mass">10</span>
                </div>
                <input type="range" id="input-mass" min="1" max="50" step="1" value="10">
            </div>

            <div class="data-display">
                <div class="data-row">
                    <span>擺角 (&theta;):</span>
                    <span class="data-val" id="disp-theta">0.0°</span>
                </div>
                <div class="data-row">
                    <span>繩張力 (T):</span>
                    <span class="data-val" id="disp-tension">-- N</span>
                </div>
                <div class="data-row">
                    <span>向心力 (Fc):</span>
                    <span class="data-val" id="disp-fc">-- N</span>
                </div>
            </div>

            <div class="legend-box">
                <div class="legend-item"><div class="color-box" style="background:#d32f2f;"></div> Fc (向心力 / 合力)</div>
                <div class="legend-item"><div class="color-box" style="background:#1565c0;"></div> T (繩張力)</div>
                <div class="legend-item"><div class="color-box" style="background:#2e7d32;"></div> mg (重力)</div>
                <div class="legend-item" style="margin-top:8px; border-top:1px solid #eee; padding-top:5px;"><span style="color:#888; font-size: 12px;">--- 灰色虛線: 旋轉軌跡</span></div>
                <div class="legend-item"><span style="color:#ff5722; font-size: 12px;">--- 橘色虛線: 旋轉半徑 (L sinθ)</span></div>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, labelRenderer, controls;
        let mainGroup, arrows = {}, labels = {};
        let objects = {};
        
        const POLE_HEIGHT = 40;
        const STRING_LEN = 30;
        // MASS 改為動態變數 params.mass

        let params = {
            velocity: 10.0,
            mass: 10.0, // 新增質量參數
            paused: false,
            theta: 0,
            time: 0
        };

        const uiVelocity = document.getElementById('input-velocity');
        const uiValVelocity = document.getElementById('val-velocity');
        const uiMass = document.getElementById('input-mass');
        const uiValMass = document.getElementById('val-mass');

        const dispTheta = document.getElementById('disp-theta');
        const dispTension = document.getElementById('disp-tension');
        const dispFc = document.getElementById('disp-fc');
        const fbdCanvas = document.getElementById('fbd-canvas');
        const fbdCtx = fbdCanvas.getContext('2d');
        
        window.onload = function() {
            init();
            if(window.innerWidth < 850) { }
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5); 
            scene.fog = new THREE.Fog(0xf0f2f5, 50, 300);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 100); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 20, 0);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);
            scene.add(new THREE.GridHelper(300, 60, 0xdddddd, 0xeeeeee));

            createSceneObjects();

            // 速度監聽
            uiVelocity.addEventListener('input', (e) => {
                params.velocity = parseFloat(e.target.value);
                uiValVelocity.innerText = params.velocity.toFixed(1);
            });

            // [新增] 質量監聽
            uiMass.addEventListener('input', (e) => {
                params.mass = parseFloat(e.target.value);
                uiValMass.innerText = params.mass.toFixed(0);
                
                // 調整球體大小 (視覺回饋)
                // 10kg 是基礎大小 1.5，最大 50kg -> 縮放
                const newScale = 1 + (params.mass - 10) / 40 * 0.5; // 稍微變大一點
                objects.bob.scale.set(newScale, newScale, newScale);
            });

            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function togglePanel() {
            const panel = document.getElementById('ui-panel');
            const icon = document.getElementById('panel-toggle-icon');
            panel.classList.toggle('collapsed');
            icon.innerText = panel.classList.contains('collapsed') ? '▲' : '▼';
        }

        function toggleFBD() {
            const container = document.getElementById('fbd-container');
            const icon = document.getElementById('fbd-toggle-icon');
            container.classList.toggle('collapsed');
            icon.innerText = container.classList.contains('collapsed') ? '▲' : '▼';
        }

        function createSceneObjects() {
            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            const dashGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, POLE_HEIGHT, 0),
                new THREE.Vector3(0, 0, 0)
            ]);
            const dashMat = new THREE.LineDashedMaterial({ color: 0x888888, dashSize: 1.5, gapSize: 1.5 });
            objects.axisLine = new THREE.Line(dashGeo, dashMat);
            objects.axisLine.computeLineDistances();
            mainGroup.add(objects.axisLine);

            objects.topPlate = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.5, 32), new THREE.MeshStandardMaterial({color: 0x333}));
            objects.topPlate.position.y = POLE_HEIGHT;
            mainGroup.add(objects.topPlate);

            objects.bob = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), new THREE.MeshStandardMaterial({color: 0xffaa00}));
            objects.bob.castShadow = true;
            mainGroup.add(objects.bob);

            const stringGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, POLE_HEIGHT, 0), new THREE.Vector3(0,0,0)]);
            objects.string = new THREE.Line(stringGeo, new THREE.LineBasicMaterial({color: 0x222, linewidth: 2}));
            mainGroup.add(objects.string);

            const radiusLineGeo = new THREE.BufferGeometry();
            const radiusLineMat = new THREE.LineDashedMaterial({ color: 0xff5722, dashSize: 1, gapSize: 0.5 }); 
            objects.radiusLine = new THREE.Line(radiusLineGeo, radiusLineMat);
            mainGroup.add(objects.radiusLine);

            const pathCircleGeo = new THREE.BufferGeometry();
            const pathCircleMat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 1, gapSize: 1 }); 
            objects.pathCircle = new THREE.Line(pathCircleGeo, pathCircleMat);
            objects.pathCircle.rotation.x = Math.PI / 2;
            mainGroup.add(objects.pathCircle);

            objects.arcLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xff8f00, linewidth: 2 }));
            mainGroup.add(objects.arcLine);

            const divAngle = document.createElement('div');
            divAngle.className = 'angle-label'; divAngle.innerText = "θ";
            labels.theta = new THREE.CSS2DObject(divAngle);
            scene.add(labels.theta);

            const divL = document.createElement('div');
            divL.className = 'geo-label'; divL.innerText = "L";
            labels.stringL = new THREE.CSS2DObject(divL);
            scene.add(labels.stringL);

            const divR = document.createElement('div');
            divR.className = 'geo-label'; divR.innerHTML = "L sin&theta;";
            labels.radiusLsin = new THREE.CSS2DObject(divR);
            scene.add(labels.radiusLsin);

            createArrow('mg', 0x2e7d32, 'mg'); 
            createArrow('T', 0x1565c0, 'T');   
            createArrow('Fc', 0xd32f2f, 'Fc'); 
        }

        function createArrow(name, color, text) {
            const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(), 5, color, 2, 1);
            mainGroup.add(arrow);
            arrows[name] = arrow;

            const div = document.createElement('div');
            div.className = 'force-label'; div.innerText = text;
            div.style.borderColor = '#' + color.toString(16).padStart(6,'0');
            div.style.color = '#' + color.toString(16).padStart(6,'0');
            labels[name] = new THREE.CSS2DObject(div);
            scene.add(labels[name]);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!params.paused) {
                updatePhysics();
            }
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function updatePhysics() {
            const dt = 0.016;
            const v = params.velocity;
            const m = params.mass; // 取得目前質量
            
            // 角度只跟速度有關 (tan = v^2/rg)，跟質量無關
            let theta = (v / 20) * 1.4; 
            if(theta > 1.45) theta = 1.45;
            params.theta = theta;

            const r = STRING_LEN * Math.sin(theta);
            const h = STRING_LEN * Math.cos(theta);
            const radius = Math.max(0.1, r);

            params.time -= (v / radius) * dt; 
            const x = radius * Math.cos(params.time);
            const z = radius * Math.sin(params.time);
            const y = POLE_HEIGHT - h;

            const bobPos = new THREE.Vector3(x, y, z);
            const pivotPos = new THREE.Vector3(0, POLE_HEIGHT, 0);
            const centerPos = new THREE.Vector3(0, y, 0); 

            objects.bob.position.copy(bobPos);
            objects.string.geometry.attributes.position.setXYZ(1, x, y, z);
            objects.string.geometry.attributes.position.needsUpdate = true;
            updateAngleVisuals(theta, x, z);

            objects.radiusLine.geometry.setFromPoints([centerPos, bobPos]);
            objects.radiusLine.computeLineDistances(); 

            const circleCurve = new THREE.EllipseCurve(0, 0, radius, radius, 0, 2 * Math.PI);
            objects.pathCircle.geometry.setFromPoints(circleCurve.getPoints(64));
            objects.pathCircle.position.y = y;
            objects.pathCircle.computeLineDistances();

            labels.stringL.position.copy(pivotPos).lerp(bobPos, 0.5).add(new THREE.Vector3(1, 1, 0));
            labels.radiusLsin.position.copy(centerPos).lerp(bobPos, 0.5).add(new THREE.Vector3(0, 1, 0));
            labels.radiusLsin.visible = (radius > 3);

            // 計算受力大小 (N)
            const tensionVal = (m * 9.8) / Math.cos(theta);
            const fcVal = tensionVal * Math.sin(theta);

            // 更新 3D 箭頭 (長度與質量掛勾)
            // 基礎長度 factor: mass/10。如果 mass=50，長度 x5
            // 注意: 這裡還是要避免長度太誇張，可以稍微用 log 或 sqrt 縮放，或者直接線性
            // 但因為有自動縮放，線性是可以的
            const visualScale = (m / 10); 

            updateArrow('mg', bobPos, new THREE.Vector3(0, -1, 0), 8 * visualScale);
            const dirT = new THREE.Vector3().subVectors(pivotPos, bobPos).normalize();
            updateArrow('T', bobPos, dirT, (8 / Math.cos(theta)) * visualScale); 

            const dirFc = new THREE.Vector3().subVectors(centerPos, bobPos).normalize();
            const lenFc = 8 * Math.tan(theta) * visualScale;
            const arrFc = arrows['Fc'];
            const lblFc = labels['Fc'];
            if(arrFc) {
                arrFc.position.copy(bobPos);
                arrFc.setDirection(dirFc);
                arrFc.setLength(Math.max(1, lenFc));
                const midPoint = dirFc.clone().multiplyScalar(lenFc / 2).add(bobPos);
                lblFc.position.copy(midPoint).add(new THREE.Vector3(0, -3, 0));
            }

            dispTheta.innerText = (theta * 180 / Math.PI).toFixed(1) + "°";
            dispTension.innerText = tensionVal.toFixed(0) + " N";
            dispFc.innerText = fcVal.toFixed(0) + " N";

            drawDynamicFBD(theta, m);
        }

        function updateAngleVisuals(theta, bobX, bobZ) {
            const radius = 8;
            const segments = 16;
            const points = [];
            const pivot = new THREE.Vector3(0, POLE_HEIGHT, 0);
            const currentDir = new THREE.Vector3(bobX, -STRING_LEN * Math.cos(theta), bobZ).normalize();
            const downDir = new THREE.Vector3(0, -1, 0);

            for (let i = 0; i <= segments; i++) {
                const t = i / segments; 
                const vec = new THREE.Vector3().copy(downDir).lerp(currentDir, t).normalize().multiplyScalar(radius);
                points.push(new THREE.Vector3().addVectors(pivot, vec));
            }
            objects.arcLine.geometry.setFromPoints(points);
            
            const midVec = new THREE.Vector3().copy(downDir).lerp(currentDir, 0.5).normalize().multiplyScalar(radius + 4);
            labels.theta.position.copy(pivot.clone().add(midVec));
        }

        function updateArrow(name, pos, dir, len) {
            const arr = arrows[name];
            const lbl = labels[name];
            if(arr && name !== 'Fc') { 
                arr.position.copy(pos);
                arr.setDirection(dir);
                arr.setLength(Math.max(1, len));
                lbl.position.copy(dir.clone().multiplyScalar(len + 2).add(pos));
            }
        }

        // --- FBD 繪圖 ---
        function drawDynamicFBD(theta, mass) {
            const ctx = fbdCtx;
            const W = fbdCanvas.width;
            const H = fbdCanvas.height;
            const CX = W / 2;
            const CY = H / 2 + 20; 

            ctx.clearRect(0, 0, W, H);

            // [修改] 基礎長度隨質量變化
            // 質量 10kg => 60px
            // 質量 50kg => 300px (會觸發自動縮放)
            const baseLenMG = 6 * mass; 

            let lenT = baseLenMG / Math.cos(theta);
            let lenFc = baseLenMG * Math.tan(theta);

            const maxRadius = Math.min(W, H) / 2 - 15; 
            const maxVectorLen = Math.max(baseLenMG, lenT, lenFc);
            
            let scale = 1;
            if (maxVectorLen > maxRadius) {
                scale = maxRadius / maxVectorLen;
            }

            const drawLenMG = baseLenMG * scale;
            const drawLenT = lenT * scale;
            const drawLenFc = lenFc * scale;

            ctx.beginPath();
            ctx.strokeStyle = '#e0e0e0';
            ctx.setLineDash([5, 5]);
            ctx.moveTo(CX, 0); ctx.lineTo(CX, H);
            ctx.moveTo(0, CY); ctx.lineTo(W, CY);
            ctx.stroke();
            ctx.setLineDash([]);

            // 球體大小也隨質量微調
            const boxSize = 24 + (mass - 10)/2;
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(CX - boxSize/2, CY - boxSize/2, boxSize, boxSize);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(CX - boxSize/2, CY - boxSize/2, boxSize, boxSize);

            drawVector(ctx, CX, CY, 0, drawLenMG, '#2e7d32', 'mg');
            const tx = -Math.sin(theta) * drawLenT;
            const ty = -Math.cos(theta) * drawLenT;
            drawVector(ctx, CX, CY, tx, ty, '#1565c0', 'T');
            drawVector(ctx, CX, CY, -drawLenFc, 0, '#d32f2f', 'Fc');

            const rArc = 30 * scale; 
            const actualRArc = Math.max(20, Math.min(rArc, 40)); 
            ctx.beginPath();
            ctx.strokeStyle = '#ff8f00';
            ctx.lineWidth = 2;
            ctx.arc(CX, CY, actualRArc, -Math.PI/2 - theta, -Math.PI/2);
            ctx.stroke();
            
            ctx.fillStyle = '#ff8f00';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText("θ", CX - 10, CY - actualRArc - 5);
        }

        function drawVector(ctx, x, y, dx, dy, color, label) {
            ctx.beginPath();
            ctx.lineWidth = 3;
            ctx.strokeStyle = color;
            ctx.moveTo(x, y);
            ctx.lineTo(x + dx, y + dy);
            ctx.stroke();

            const angle = Math.atan2(dy, dx);
            const headLen = 10;
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(x + dx, y + dy);
            ctx.lineTo(x + dx - headLen * Math.cos(angle - Math.PI/6), y + dy - headLen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x + dx - headLen * Math.cos(angle + Math.PI/6), y + dy - headLen * Math.sin(angle + Math.PI/6));
            ctx.fill();

            ctx.font = "bold 15px Arial";
            ctx.fillStyle = color;
            let textX = x + dx;
            let textY = y + dy;
            
            if (label === 'mg') {
                textX += 12; 
                textY += 5;  
            } else {
                if (dx > 0) textX += 8; else textX -= 25;
                if (dy > 0) textY += 20; else textY -= 8;
            }
            
            ctx.fillText(label, textX, textY);
        }

        function togglePause() {
            params.paused = !params.paused;
            const btn = document.getElementById('btn-pause');
            if(params.paused) {
                btn.innerText = "繼續 (Resume)";
                btn.classList.add('paused');
            } else {
                btn.innerText = "暫停 / 繼續 (Pause)";
                btn.classList.remove('paused');
            }
        }

        function resetSim() {
            params.velocity = 10.0;
            uiVelocity.value = 10.0;
            uiValVelocity.innerText = "10.0";
            
            // [新增] 重置質量
            params.mass = 10.0;
            uiMass.value = 10.0;
            document.getElementById('val-mass').innerText = "10";
            objects.bob.scale.set(1, 1, 1);

            params.theta = 0;
            params.time = 0;
            if(params.paused) togglePause();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>