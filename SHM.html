<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SHM 投影演示</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f4f7f6;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    margin: 0;
  }

  .container {
    background: white;
    padding: 25px;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    text-align: center;
    width: 750px;
    max-width: 95%;
  }

  h1 { margin: 0 0 10px 0; color: #2c3e50; font-size: 1.6rem; }
  
  .formula-box {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 15px;
    font-family: 'Times New Roman', serif;
    font-style: italic;
    font-size: 1.2rem;
    color: #555;
    flex-wrap: wrap;
  }

  .highlight-red { color: #e74c3c; font-weight: bold; }

  canvas {
    background-color: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-image: 
      linear-gradient(#f9f9f9 1px, transparent 1px),
      linear-gradient(90deg, #f9f9f9 1px, transparent 1px);
    background-size: 20px 20px;
  }

  .controls {
    margin-top: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  /* 3D 按鈕樣式 */
  .btn-3d {
    background: linear-gradient(135deg, #6c5ce7, #a29bfe);
    color: white;
    border: none;
    padding: 10px 25px;
    font-size: 1rem;
    border-radius: 50px;
    cursor: pointer;
    font-weight: bold;
    box-shadow: 0 4px 10px rgba(108, 92, 231, 0.4);
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .btn-3d:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(108, 92, 231, 0.5);
  }

  /* 角度控制區 */
  .angle-control-box {
    display: flex;
    align-items: center;
    gap: 15px;
    background: #fff3cd;
    border: 1px solid #ffeeba;
    padding: 8px 20px;
    border-radius: 8px;
    color: #856404;
  }
  
  .angle-input {
    width: 70px;
    padding: 5px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    text-align: center;
    font-size: 1rem;
    font-weight: bold;
  }
  .angle-input:disabled {
    background-color: #e9ecef;
    color: #6c757d;
    cursor: not-allowed;
  }

  .checkbox-group {
    display: flex;
    gap: 20px;
    background: #f8f9fa;
    padding: 10px 20px;
    border-radius: 8px;
    flex-wrap: wrap; justify-content: center;
  }

  .cb-item {
    display: flex;
    align-items: center;
    font-weight: bold;
    cursor: pointer;
    font-size: 0.95rem;
    user-select: none;
  }

  input[type="checkbox"] { width: 18px; height: 18px; margin-right: 8px; cursor: pointer; }

  .legend {
    margin-top: 15px;
    font-size: 0.9rem;
    color: #7f8c8d;
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
  }
  .legend span { display: flex; align-items: center; gap: 5px; }
  .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
</style>
</head>
<body>

<div class="container">
  <h1>SHM 投影與座標系演示 (指定角度版)</h1>
  
  <div class="formula-box">
    <span>x = R cos(θ)</span>
    <span>v = -Rω sin(θ)</span>
    <span class="highlight-red">a = -Rω² cos(θ)</span>
  </div>

  <canvas id="simCanvas" width="700" height="400"></canvas>

  <div class="controls">
    
    <button class="btn-3d" id="rotateBtn">旋轉視角 (查看參考圓)</button>

    <div class="angle-control-box">
      <label class="cb-item">
        <input type="checkbox" id="pauseCheck"> 指定角度停格：
      </label>
      <input type="number" id="angleInput" class="angle-input" value="45" min="0" max="720" step="15" disabled>
      <span>度 (deg)</span>
    </div>

    <div class="checkbox-group">
      <label class="cb-item" style="color: #0984e3;">
        <input type="checkbox" id="checkDisp" checked> 位移 (R) 與角度 θ
      </label>
      <label class="cb-item" style="color: #00b894;">
        <input type="checkbox" id="checkVel"> 速度 (v)
      </label>
      <label class="cb-item" style="color: #d63031;">
        <input type="checkbox" id="checkAcc"> 加速度 (a)
      </label>
    </div>
  </div>

  <div class="legend">
    <span><span class="dot" style="background:#aaa"></span> 虛線：投影關係</span>
    <span><span class="dot" style="background:rgba(0,0,0,0.2)"></span> 淡色：母向量</span>
    <span><span class="dot" style="background:#000"></span> 深色：子向量</span>
  </div>
</div>

<script>
  const canvas = document.getElementById('simCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  // --- 物理常數 ---
  const centerX = width / 2;
  const centerY = height / 2 + 20; 
  const radius = 130;              
  const angularVel = 0.02;
  let time = 0;

  // --- 視角與狀態變數 ---
  let viewAngle = 0; 
  let targetViewAngle = 0;
  let isRotating = false;
  let isPaused = false; // 是否處於手動角度模式

  // --- DOM ---
  const rotateBtn = document.getElementById('rotateBtn');
  const pauseCheck = document.getElementById('pauseCheck');
  const angleInput = document.getElementById('angleInput');
  const checkDisp = document.getElementById('checkDisp');
  const checkVel = document.getElementById('checkVel');
  const checkAcc = document.getElementById('checkAcc');

  // 事件：切換視角
  rotateBtn.addEventListener('click', () => {
    isRotating = !isRotating;
    targetViewAngle = isRotating ? 1 : 0;
    rotateBtn.textContent = isRotating ? "回到側面視角 (SHM)" : "旋轉視角 (查看參考圓)";
  });

  // 事件：啟用/停用 指定角度模式
  pauseCheck.addEventListener('change', () => {
    isPaused = pauseCheck.checked;
    angleInput.disabled = !isPaused; // 啟用或鎖定輸入框
    
    if (isPaused) {
        // 剛勾選時，將目前的角度填入輸入框，避免跳動
        // 計算當前角度 (度)
        let currentTheta = (time * angularVel) % (Math.PI * 2);
        if (currentTheta < 0) currentTheta += Math.PI * 2;
        let deg = Math.round(currentTheta * 180 / Math.PI);
        angleInput.value = deg;
    }
  });

  // --- 繪圖函式 ---

  function drawVector(fromX, fromY, vecX, vecY, color, label, style = 'solid', labelOffset = {x:0, y:0}) {
    const toX = fromX + vecX;
    const toY = fromY + vecY;
    const lenSq = vecX * vecX + vecY * vecY;

    if (lenSq > 4) {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        
        if (style === 'ghost') {
          ctx.globalAlpha = 0.3; 
          ctx.setLineDash([5, 3]); 
          ctx.lineWidth = 2;
        } else {
          ctx.globalAlpha = 1.0;
          ctx.lineWidth = 3;
        }

        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        ctx.setLineDash([]); 

        const angle = Math.atan2(vecY, vecX);
        const headLen = style === 'ghost' ? 8 : 12;
        
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();

        if (label && style === 'solid') {
          ctx.font = "bold 15px Arial";
          let lx = toX + (labelOffset.x || 0);
          let ly = toY + (labelOffset.y || -8);
          if (vecY > 0 && !labelOffset.y) ly = toY + 20;
          ctx.fillText(label, lx, ly);
        }
        ctx.restore();
    }
    return { x: toX, y: toY };
  }

  function drawProjectionLine(p1, p2, color) {
    if (!p1 || !p2) return;
    if (!isRotating && viewAngle < 0.1) return;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.5;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    ctx.restore();
  }

  function drawAxes(opacity) {
      if (opacity <= 0.01) return;
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.strokeStyle = "#999";
      ctx.lineWidth = 1;
      ctx.font = "italic 18px Times New Roman";
      ctx.fillStyle = "#666";

      // X軸
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.stroke();
      ctx.fillText("x", width - 20, centerY + 20);

      // Y軸
      let yLen = (height/2 - 20) * viewAngle;
      if (yLen > 5) {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - yLen);
        ctx.lineTo(centerX, centerY + yLen);
        ctx.stroke();
        ctx.fillText("y", centerX - 20, 30);
      }
      
      ctx.fillText("O", centerX - 20, centerY + 20);
      ctx.restore();
  }

  function drawAngleMark(totalTheta) {
      if (viewAngle < 0.2) return;

      let cycleTheta = totalTheta % (Math.PI * 2);
      if (cycleTheta < 0) cycleTheta += Math.PI * 2; // 處理負角度輸入

      ctx.save();
      const arcRadiusX = 40; 
      const arcRadiusY = 40 * viewAngle;

      ctx.beginPath();
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 1.5;
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)"; 

      // 逆時針畫圓弧
      ctx.ellipse(centerX, centerY, arcRadiusX, arcRadiusY, 0, 0, -cycleTheta, true);
      
      ctx.stroke();
      ctx.lineTo(centerX, centerY);
      ctx.fill();

      // 文字
      const labelDist = 55;
      const labelX = centerX + labelDist * Math.cos(-cycleTheta); 
      const labelY = centerY + labelDist * Math.sin(-cycleTheta) * viewAngle; 
      
      ctx.font = "italic bold 16px Times New Roman";
      ctx.fillStyle = "#333";
      ctx.fillText("θ", labelX, labelY);
      
      ctx.restore();
  }


  function loop() {
    try {
        ctx.clearRect(0, 0, width, height);

        // 1. 動畫過渡視角
        viewAngle += (targetViewAngle - viewAngle) * 0.05;

        // 2. 決定當前角度 Theta
        let theta;
        
        if (isPaused) {
            // --- 暫停模式 (手動角度) ---
            // 讀取輸入框數值
            let deg = parseFloat(angleInput.value) || 0;
            theta = deg * (Math.PI / 180);
            
            // 關鍵：持續更新全域 time 變數，讓它與手動角度同步
            // 這樣一取消勾選，動畫就會從這個角度繼續跑，而不會跳針
            time = theta / angularVel; 
            
        } else {
            // --- 自動播放模式 ---
            time++; 
            theta = angularVel * time;
        }

        let cosT = Math.cos(theta);
        let sinT = Math.sin(theta); 

        // 座標計算
        let posX_3d = radius * cosT; 
        let posZ_3d = -radius * sinT; 
        
        let shmX = centerX + posX_3d;
        let shmY = centerY;
        let ucmX = shmX;
        let ucmY = centerY + posZ_3d * viewAngle;

        // --- 繪圖層 ---

        // 背景圓
        ctx.beginPath();
        ctx.ellipse(centerX, centerY, radius, radius * viewAngle, 0, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(200, 200, 200, 0.4)";
        ctx.lineWidth = 2;
        ctx.stroke();

        drawAxes(viewAngle);
        
        // SHM 軸
        if (viewAngle < 0.01) {
             ctx.beginPath();
             ctx.moveTo(0, centerY);
             ctx.lineTo(width, centerY);
             ctx.strokeStyle = "#ccc";
             ctx.stroke();
             ctx.fillStyle = "#666";
             ctx.fillText("x", width - 20, centerY - 10);
             ctx.beginPath(); ctx.moveTo(centerX, centerY-10); ctx.lineTo(centerX, centerY+10); ctx.stroke();
        }

        // 投影線
        if (viewAngle > 0.05) {
          drawProjectionLine({x: ucmX, y: ucmY}, {x: shmX, y: shmY}, "#999");
          ctx.beginPath(); ctx.arc(shmX, shmY, 5, 0, Math.PI*2); ctx.fillStyle = "#bdc3c7"; ctx.fill();
        }

        // UCM 質點
        ctx.beginPath();
        ctx.arc(ucmX, ucmY, 12, 0, Math.PI * 2);
        ctx.fillStyle = "#2c3e50";
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.stroke();

        // --- 向量 ---

        // 1. 位移
        if (checkDisp.checked) {
          let vecX = ucmX - centerX;
          let vecY = ucmY - centerY;
          let tip2D = drawVector(centerX, centerY, vecX, vecY, "#74b9ff", null, 'ghost');
          
          drawAngleMark(theta);
          
          let tip1D = drawVector(centerX, centerY, shmX - centerX, 0, "#0984e3", "x", 'solid', {x:0, y:-10});
          drawProjectionLine(tip2D, tip1D, "#0984e3");
        }

        // 2. 速度
        if (checkVel.checked) {
          const vScale = 35;
          let v_mag = radius * angularVel;
          let vx = -v_mag * sinT;
          let vz = -v_mag * cosT;
          let vecX = vx * vScale;
          let vecY = vz * vScale * viewAngle;

          let tip2D = drawVector(ucmX, ucmY, vecX, vecY, "#55efc4", null, 'ghost');
          let tip1D = drawVector(shmX, shmY, vecX, 0, "#00b894", "v", 'solid', {x:0, y:20});
          drawProjectionLine(tip2D, tip1D, "#00b894");
        }

        // 3. 加速度
        if (checkAcc.checked) {
          const aScale = 2500;
          let a_mag = radius * Math.pow(angularVel, 2);
          let ax = -a_mag * cosT;
          let az = a_mag * sinT;
          let vecX = ax * aScale;
          let vecY = az * aScale * viewAngle;

          let tip2D = drawVector(ucmX, ucmY, vecX, vecY, "#ff7675", null, 'ghost');
          let tip1D = drawVector(shmX, shmY, vecX, 0, "#d63031", "a", 'solid', {x:0, y:25});
          drawProjectionLine(tip2D, tip1D, "#d63031");
        }

        requestAnimationFrame(loop);
    } catch (e) { console.error(e); }
  }

  loop();
</script>

</body>
</html>