<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é«˜ä¸­ç‰©ç†ï¼šæ³¢å‹•å¯¦é©—å®¤ (å®Œç¾é›™æ›²ç·šç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; }
        
        /* === ç›´å‘è­¦å‘Š === */
        #orientation-warning {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(26, 26, 26, 0.95); z-index: 9999;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; backdrop-filter: blur(10px);
        }
        @media screen and (orientation: portrait) {
            #orientation-warning { display: flex; }
            #ui-left, #ui-right { display: none !important; }
        }

        /* === ä»‹é¢é¢æ¿ === */
        .ui-panel {
            position: absolute; top: 15px; 
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; overflow: hidden;
            transition: all 0.3s ease; z-index: 10;
        }
        #ui-left { left: 15px; width: 300px; max-height: 90vh; }
        #ui-right { right: 15px; width: 350px; max-height: 90vh; }

        @media screen and (max-height: 500px) {
            .ui-panel { max-height: 85vh; }
            #ui-left, #ui-right { width: 260px; max-width: 45vw; }
        }

        .ui-panel.collapsed { height: 45px !important; }
        .ui-panel.collapsed .ui-content { display: none; }

        .header {
            padding: 0 15px; background: #f8f9fa; border-bottom: 3px solid #0056b3;
            display: flex; justify-content: space-between; align-items: center;
            height: 45px; flex-shrink: 0;
        }
        h2 { margin: 0; color: #0056b3; font-size: 1.1rem; font-weight: 700; }
        
        .toggle-collapse-btn {
            background: none; border: none; padding: 4px; color: #666;
            cursor: pointer; font-size: 0.9rem; white-space: nowrap;
        }
        .toggle-collapse-btn:hover { color: #0056b3; text-decoration: underline; }

        .ui-content { padding: 15px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        
        .section-title { 
            font-size: 0.9rem; font-weight: bold; color: #444; 
            margin: 12px 0 6px 0; text-transform: uppercase; letter-spacing: 1px; 
            border-bottom: 1px solid #eee; padding-bottom: 4px;
        }

        .btn-group { display: flex; gap: 8px; margin-bottom: 10px; }
        button {
            flex: 1; padding: 8px; border: none; border-radius: 6px;
            background: #e9ecef; color: #333; cursor: pointer; font-weight: 600; font-size: 0.9rem;
            transition: 0.2s;
        }
        button:hover { background: #dbe2e8; }
        button.active { background: #007bff; color: white; }
        button.warning { background: #ffc107; color: #333; }
        
        .toggle-btn { display: flex; justify-content: space-between; align-items: center; width: 100%; text-align: left; margin-bottom: 5px; padding: 8px;}
        .toggle-btn span.status { font-size: 0.8rem; background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px; }
        .toggle-btn.on { background: #28a745; color: white; }
        .toggle-btn.on span.status { background: rgba(255,255,255,0.3); }
        .toggle-btn.measure.on { background: #6f42c1; color: white;}

        .control-box { background: #fff9db; padding: 12px; border-radius: 8px; margin-top: 8px; border: 1px solid #ffe066; }
        .slider-row { margin-bottom: 10px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 4px; font-weight: 600; color: #444; }
        input[type=range] { width: 100%; cursor: pointer; }

        details { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; margin-bottom: 8px; }
        summary { padding: 8px 12px; cursor: pointer; font-weight: bold; color: #495057; outline: none; display: flex; justify-content: space-between; }
        summary::after { content: 'â–¼'; font-size: 0.8rem; transition: transform 0.2s; }
        details[open] summary::after { transform: rotate(180deg); }
        
        .formula-content { padding: 10px 12px; border-top: 1px solid #eee; background: white; }
        .formula-row { 
            font-family: 'Times New Roman', serif; font-size: 1.1rem; 
            margin-bottom: 8px; color: #333; line-height: 1.5;
        }
        .formula-sub { font-size: 0.85rem; color: #666; font-family: sans-serif; margin-left: 5px; }
        .calc-step { display: block; font-size: 1rem; color: #555; margin-left: 10px; border-left: 3px solid #eee; padding-left: 8px; margin-top: 4px; }
        .calc-val { color: #0056b3; font-weight: bold; font-family: monospace; } 

        .data-table { width: 100%; border-collapse: collapse; margin-top: 5px; }
        .data-table td { padding: 4px 0; border-bottom: 1px dashed #eee; font-size: 0.9rem; }
        .data-val { font-weight: bold; color: #0056b3; font-family: monospace; font-size: 1.05rem; float: right;}

        #path-diff-result { margin-top: 15px; padding: 12px; border-radius: 8px; background: #e8eaf6; border: 1px solid #c5cae9; display: none; }
        .result-tag { display: block; text-align: center; font-weight: bold; color: white; padding: 6px; border-radius: 4px; margin-top: 8px; font-size: 0.95rem; }
        .tag-constructive { background: #d9534f; } 
        .tag-destructive { background: #f0ad4e; } 
        .tag-normal { background: #6c757d; }

        .label-marker {
            position: absolute; background: rgba(255,255,255,0.9); padding: 2px 6px;
            border-radius: 4px; border: 1px solid #ccc; font-size: 0.8rem; font-weight: bold;
            color: #333; pointer-events: none; transform: translate(-50%, -50%); z-index: 5;
            white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .guide-box { background: #e7f5ff; padding: 15px; border-radius: 8px; font-size: 0.95rem; line-height: 1.6; color: #004085; border-left: 5px solid #007bff; }
        .mode-specific { display: block; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="orientation-warning">
        <div style="font-size:3rem; margin-bottom:20px;">ğŸ“±</div>
        <h2 style="color:white;">è«‹æ©«å‘ä½¿ç”¨è£ç½®</h2>
    </div>

    <div id="labels-container"></div>

    <div id="ui-left" class="ui-panel">
        <div class="header">
            <h2>ğŸŒŠ æ³¢å‹•å¯¦é©—å®¤</h2>
            <button class="toggle-collapse-btn" onclick="togglePanel('ui-left', this)">æ”¶èµ·</button>
        </div>
        <div id="ui-content-left" class="ui-content">
            <div class="section-title">å¯¦é©—æ¨¡å¼</div>
            <div class="btn-group">
                <button id="btn-single" onclick="setMode('single')">å–®æ³¢æº</button>
                <button id="btn-interference" onclick="setMode('interference')">é›™æ³¢æºå¹²æ¶‰</button>
            </div>

            <div id="group-single" class="mode-specific">
                 <button id="btn-wavefront-single" class="toggle-btn" onclick="toggleWavefronts()">
                    <span>â­• é¡¯ç¤ºæ³¢å‰ (ç´”å¹¾ä½•)</span><span class="status">é—œé–‰</span>
                </button>
            </div>

            <div id="group-interference" class="mode-specific hidden">
                <div class="control-box">
                    <div class="slider-row">
                        <div class="slider-label">
                            <span>æ³¢æºè·é›¢ (d)</span>
                            <span id="dist-val">12.0</span>
                        </div>
                        <input type="range" min="6" max="24" value="12" step="0.5" oninput="updateSeparation(this.value)">
                    </div>
                    <div class="slider-row">
                        <div class="slider-label">
                            <span>ç›¸ä½å·® (Phase)</span>
                            <span id="phase-val">0Â°</span>
                        </div>
                        <input type="range" min="0" max="180" value="0" step="15" oninput="updatePhase(this.value)">
                    </div>
                </div>

                <div style="margin-top:10px;">
                    <button id="btn-path-diff" class="toggle-btn measure" onclick="togglePathDiffMode()">
                        <span>ğŸ“ æ¸¬é‡æ³¢ç¨‹å·® (é»æ“Šæ°´é¢)</span><span class="status">é—œé–‰</span>
                    </button>
                    <button id="btn-wavefront-int" class="toggle-btn" onclick="toggleWavefronts()">
                        <span>â­• é¡¯ç¤ºæ³¢å‰ (éš±è—æ°´é¢)</span><span class="status">é—œé–‰</span>
                    </button>
                    <button id="btn-analysis" class="toggle-btn" onclick="toggleAnalysis()">
                        <span>ğŸ“Š é¡¯ç¤ºç¯€ç·šèˆ‡è…¹ç·š</span><span class="status">é—œé–‰</span>
                    </button>
                </div>
            </div>

            <div class="section-title">æ™‚é–“æ§åˆ¶</div>
            <div class="btn-group">
                <button id="btn-pause" class="warning" onclick="togglePause()">â¸ æš«åœ</button>
                <button id="btn-slow" onclick="toggleSlow()">ğŸ¢ æ…¢å‹•ä½œ</button>
                <button onclick="resetSim()" style="background:#6c757d; color:white;">â†º é‡ç½®</button>
            </div>
        </div>
    </div>

    <div id="ui-right" class="ui-panel">
        <div class="header">
            <h2>ğŸ“ æ•¸æ“šèˆ‡å…¬å¼</h2>
            <button class="toggle-collapse-btn" onclick="togglePanel('ui-right', this)">æ”¶èµ·</button>
        </div>
        <div id="ui-content-right" class="ui-content">
            </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- ç‰©ç†åƒæ•¸ ---
        const CONFIG = {
            gridSize: 100,
            planeSize: 60,
            waveSpeed: 3.0,
            waveFreq: 1.0,
            amplitude: 1.5,
            sourceSpacing: 12
        };
        let WAVELENGTH = CONFIG.waveSpeed / CONFIG.waveFreq; // = 3.0

        let scene, camera, renderer, controls;
        let waterMesh, waterGeo;
        let clock = new THREE.Clock();
        
        let state = {
            mode: 'single', 
            paused: false,
            slowMotion: false,
            showWavefronts: false, 
            showAnalysis: false,
            pathDiffMode: false,
            phaseOffset: 0,
            virtualTime: 0
        };

        let sources = [];
        let markersGroup, wavefrontGroup, analysisGroup, measurementGroup;
        let clickedPoint = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xaaccff);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 65, 50); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(30, 50, 30);
            sun.castShadow = true;
            sun.shadow.camera.left = -40; sun.shadow.camera.right = 40;
            sun.shadow.camera.top = 40; sun.shadow.camera.bottom = -40;
            sun.shadow.mapSize.width = 2048; 
            scene.add(sun);

            waterGeo = new THREE.PlaneGeometry(CONFIG.planeSize, CONFIG.planeSize, CONFIG.gridSize, CONFIG.gridSize);
            const waterMat = new THREE.MeshPhongMaterial({ 
                color: 0x0077be, shininess: 120, specular: 0x222222,
                side: THREE.DoubleSide, flatShading: false, transparent: true, opacity: 0.9
            });
            waterMesh = new THREE.Mesh(waterGeo, waterMat);
            waterMesh.rotation.x = -Math.PI / 2;
            waterMesh.receiveShadow = true;
            scene.add(waterMesh);

            markersGroup = new THREE.Group(); scene.add(markersGroup); 
            wavefrontGroup = new THREE.Group(); scene.add(wavefrontGroup); 
            analysisGroup = new THREE.Group(); scene.add(analysisGroup); 
            measurementGroup = new THREE.Group(); scene.add(measurementGroup); 

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2; 

            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('pointerdown', onWaterClick);

            setMode('single');
            animate();
        }

        function togglePanel(panelId, btn) {
            const panel = document.getElementById(panelId);
            panel.classList.toggle('collapsed');
            btn.innerText = panel.classList.contains('collapsed') ? 'å±•é–‹' : 'æ”¶èµ·';
        }

        function setMode(modeName) {
            state.mode = modeName;
            document.getElementById('btn-single').className = modeName === 'single' ? 'active' : '';
            document.getElementById('btn-interference').className = modeName === 'interference' ? 'active' : '';
            document.getElementById('group-single').classList.toggle('hidden', modeName !== 'single');
            document.getElementById('group-interference').classList.toggle('hidden', modeName !== 'interference');
            
            state.showWavefronts = false;
            state.showAnalysis = false;
            state.pathDiffMode = false;
            clickedPoint = null;
            clearLabels();

            updateToggleBtn('btn-wavefront-single', false);
            updateToggleBtn('btn-wavefront-int', false);
            updateToggleBtn('btn-analysis', false);
            updateToggleBtn('btn-path-diff', false);

            resetSim(); 
            updateRightPanel(); 
        }

        function updateRightPanel() {
            const contentDiv = document.getElementById('ui-content-right');
            if (state.mode === 'single') {
                contentDiv.innerHTML = `
                    <div class="section-title">ğŸ“˜ å­¸ç¿’å¼•å°</div>
                    <div class="guide-box">
                        <p><b>å¯¦é©—ç›®æ¨™ï¼š</b><br>è§€å¯Ÿæ³¢çš„å‚³éèˆ‡ã€Œæ³¢å‰ã€çš„å®šç¾©ã€‚</p>
                        <hr style="border:0; border-top:1px dashed #ccc; margin:10px 0;">
                        <p><b>æ³¢å‰ (Wavefront)ï¼š</b><br>
                        é–‹å•Ÿã€Œé¡¯ç¤ºæ³¢å‰ã€åŠŸèƒ½ï¼Œæ‚¨æœƒçœ‹åˆ°ç™½è‰²çš„å¹¾ä½•åœ“åœˆã€‚<br>
                        é€™äº›åœ“åœˆä»£è¡¨æ‰€æœ‰<b>ç›¸ä½ç›¸åŒ</b>ï¼ˆä¾‹å¦‚æ³¢å³°ï¼‰çš„é»é€£èµ·ä¾†çš„ç·šã€‚</p>
                    </div>
                `;
            } else {
                contentDiv.innerHTML = `
                    <div class="section-title">1. ç’°å¢ƒåƒæ•¸</div>
                    <table class="data-table">
                        <tr><td>æ³¢é•· (Î»)</td><td><span class="data-val">${WAVELENGTH.toFixed(1)}</span></td></tr>
                        <tr><td>æ³¢æºè·é›¢ (d)</td><td><span class="data-val" id="val-d">${CONFIG.sourceSpacing.toFixed(1)}</span></td></tr>
                        <tr style="background:#fff9c4;"><td><strong>æ¯”å€¼ (d / Î»)</strong></td><td><span class="data-val" id="val-ratio">--</span></td></tr>
                    </table>

                    <div style="height:10px;"></div>

                    <details open>
                        <summary>2. æ³¢ç¨‹å·®å…¬å¼ (Î”L)</summary>
                        <div class="formula-content">
                            <div class="formula-row">
                                Î”L = nÎ» <span class="formula-sub">(è…¹ç·š)</span>
                            </div>
                            <div class="formula-row">
                                Î”L = (n - 0.5)Î» <span class="formula-sub">(ç¯€ç·š)</span>
                            </div>
                        </div>
                    </details>

                    <details open>
                        <summary>3. ç¯€ç·šæ•¸é©—è­‰ (N)</summary>
                        <div class="formula-content">
                            <div class="formula-row">
                                N = 2n <span class="formula-sub">(ç¸½æ•¸)</span>
                            </div>
                            <div class="formula-row">
                                <span style="font-size:0.95rem;">æ¨å°æ¢ä»¶ï¼š n â‰¤ d/Î» + 0.5</span>
                            </div>
                            <div class="formula-row">
                                <span class="calc-step">
                                    n â‰¤ <span id="calc-d" class="calc-val">--</span> / 
                                    <span id="calc-lambda" class="calc-val">--</span> + 0.5
                                </span>
                                <span class="calc-step">
                                    n â‰¤ <span id="calc-result" class="calc-val">--</span>
                                </span>
                            </div>
                            <div class="formula-row" style="margin-top:5px; border-top:1px dashed #eee; padding-top:5px;">
                                âˆ´ æœ€å¤§æ•´æ•¸ n = <span id="calc-n-max" class="calc-val">--</span>
                            </div>
                            <div class="formula-row">
                                ç¸½ç¯€ç·šæ•¸ N = 2 Ã— <span id="calc-n-max-2" class="calc-val">--</span> = <span id="val-node-count" style="font-weight:bold; color:#d9534f; font-size:1.2rem;">--</span>
                            </div>
                        </div>
                    </details>

                    <div id="path-diff-result">
                        <div style="font-weight:bold; color:#6f42c1; margin-bottom:8px; border-bottom:1px solid #ccc; padding-bottom:5px;">ğŸ“ æ¸¬é‡çµæœ</div>
                        <table class="data-table">
                            <tr><td>PS<sub>1</sub></td><td><span class="data-val" id="res-ps1">--</span></td></tr>
                            <tr><td>PS<sub>2</sub></td><td><span class="data-val" id="res-ps2">--</span></td></tr>
                            <tr><td><strong>Î”L</strong></td><td><span class="data-val" id="res-delta">--</span></td></tr>
                            <tr><td>Î”L / Î»</td><td><span class="data-val" id="res-n">--</span></td></tr>
                        </table>
                        <div id="res-tag" class="result-tag tag-normal">è«‹é»æ“Šæ°´é¢</div>
                    </div>
                `;
                updateInfoPanelData();
            }
        }

        function updateInfoPanelData() {
            const d = CONFIG.sourceSpacing;
            const lambda = WAVELENGTH;
            const ratio = d / lambda;
            const limit_val = ratio + 0.5;
            
            const elRatio = document.getElementById('val-ratio');
            if(elRatio) {
                document.getElementById('val-d').innerText = d.toFixed(1);
                elRatio.innerText = ratio.toFixed(2);

                document.getElementById('calc-d').innerText = d.toFixed(1);
                document.getElementById('calc-lambda').innerText = lambda.toFixed(1);
                document.getElementById('calc-result').innerText = limit_val.toFixed(2);
                
                // floor(limit_val) å°±æ˜¯æœ€å¤§æ•´æ•¸ n
                // ä¾‹å¦‚ d=12, lambda=3 => ratio=4 => limit=4.5 => max_n=4
                // ç¯€ç·šç‚º 0.5, 1.5, 2.5, 3.5 (å…±4æ¢ * 2 = 8)
                const max_n = Math.floor(limit_val);
                document.getElementById('calc-n-max').innerText = max_n;
                document.getElementById('calc-n-max-2').innerText = max_n;
                document.getElementById('val-node-count').innerText = max_n * 2;
            }
        }

        function togglePathDiffMode() {
            if(state.mode !== 'interference') return;
            state.pathDiffMode = !state.pathDiffMode;
            updateToggleBtn('btn-path-diff', state.pathDiffMode);
            const resBox = document.getElementById('path-diff-result');
            if (state.pathDiffMode) {
                resBox.style.display = 'block';
                if(!state.paused) togglePause(); 
            } else {
                resBox.style.display = 'none';
                clearMeasurement();
                if(state.paused) togglePause();
            }
        }

        function clearMeasurement() {
            clickedPoint = null; clearLabels();
            while(measurementGroup.children.length > 0) measurementGroup.remove(measurementGroup.children[0]);
        }

        function toggleWavefronts() {
            state.showWavefronts = !state.showWavefronts;
            updateToggleBtn('btn-wavefront-single', state.showWavefronts);
            updateToggleBtn('btn-wavefront-int', state.showWavefronts);
            if(!state.showWavefronts) {
                while(wavefrontGroup.children.length > 0) {
                    const child = wavefrontGroup.children[0];
                    if(child.geometry) child.geometry.dispose();
                    wavefrontGroup.remove(child);
                }
            }
        }

        function toggleAnalysis() {
            state.showAnalysis = !state.showAnalysis;
            updateToggleBtn('btn-analysis', state.showAnalysis);
            if(state.showAnalysis) { drawAnalysisLines(); } else {
                while(analysisGroup.children.length > 0) {
                    const child = analysisGroup.children[0];
                    if(child.geometry) child.geometry.dispose();
                    analysisGroup.remove(child);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (!state.paused) {
                const timeStep = state.slowMotion ? dt * 0.2 : dt;
                state.virtualTime += timeStep;
                updateWaterPhysics();
            }
            if (state.showWavefronts) updateWavefronts();
            if (markersGroup.visible && markersGroup.children.length === 2) { 
                markersGroup.children[0].position.y = 2.5 + Math.sin(state.virtualTime * 5) * 0.5;
                markersGroup.children[1].position.y = 2.5 + Math.sin(state.virtualTime * 5 + state.phaseOffset) * 0.5;
            }

            // ç´”å¹¾ä½•æ¨¡å¼ä¸‹éš±è—æ°´é¢
            waterMesh.visible = !state.showWavefronts;
            markersGroup.visible = !state.showWavefronts;

            updateLabelsPosition();
            controls.update();
            renderer.render(scene, camera);
        }

        function updateWaterPhysics() {
            const pos = waterGeo.attributes.position; 
            const k = CONFIG.waveFreq; 
            const w = CONFIG.waveSpeed * k;
            
            // === é—œéµï¼šå¹²æ¶‰æ¨¡å¼ç§»é™¤è¡°æ¸›ï¼Œå¯¦ç¾å®Œç¾ç¯€ç·š ===
            const isInterference = (state.mode === 'interference');
            const decayFactor = isInterference ? 0.0 : 0.025; 

            for (let i = 0; i < pos.count; i++) {
                let x = pos.getX(i); let y = pos.getY(i); let z = 0;
                for (let src of sources) {
                    const dist = Math.sqrt((x - src.x)**2 + (y - src.y)**2);
                    const t = state.virtualTime - src.start;
                    if (t > 0) {
                        let phase = dist * k - t * w;
                        if (isInterference && src.id === 2) phase += state.phaseOffset;
                        
                        let damping = Math.exp(-decayFactor * dist);
                        
                        if (src.type === 'pulse') {
                            let center = t * CONFIG.waveSpeed; let pulse = Math.exp(-Math.pow(dist - center, 2) / 15);
                            z += Math.sin(phase) * CONFIG.amplitude * pulse;
                        } else {
                            if (dist < 3) damping *= (dist/3); 
                            z += Math.sin(phase) * CONFIG.amplitude * damping;
                        }
                    }
                }
                pos.setZ(i, z);
            }
            pos.needsUpdate = true; waterGeo.computeVertexNormals();
        }

        // --- ç¹ªåœ–é‚è¼¯ (é›™æ›²ç·šæ•¸å­¸æ³•ï¼šå¹³æ»‘ä¸”ç²¾ç¢º) ---
        function drawAnalysisLines() {
            while(analysisGroup.children.length > 0) {
                const child = analysisGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                analysisGroup.remove(child);
            }

            if (!state.showAnalysis || state.mode === 'single' || sources.length < 2) return;

            const d = CONFIG.sourceSpacing;
            const lambda = WAVELENGTH;
            const phaseDist = (state.phaseOffset / (2 * Math.PI)) * lambda;

            // ç¹ªè£½é›™æ›²ç·šå‡½å¼ (Hyperbola Parametric)
            const drawHyperbola = (targetDelta, color) => {
                const effectiveDelta = targetDelta + phaseDist;
                // ç‰©ç†é™åˆ¶ï¼šä¸‰è§’å½¢ä¸ç­‰å¼ |d1 - d2| < d
                if (Math.abs(effectiveDelta) >= d * 0.999) return;

                const a = effectiveDelta / 2; // é ‚é»è·é›¢
                const c = d / 2;              // ç„¦é»è·é›¢
                const b = Math.sqrt(c * c - a * a);

                const points = [];
                const segments = 150; // ç·šæ¢è§£æåº¦
                const yLimit = CONFIG.planeSize / 1.5;

                for (let i = 0; i <= segments; i++) {
                    const y = -yLimit + (i * 2 * yLimit) / segments;
                    // x^2/a^2 - y^2/b^2 = 1 => x = +/- a * sqrt(1 + y^2/b^2)
                    // a å¸¶æœ‰æ­£è² è™Ÿ (æ±ºå®šå·¦å³æ”¯)
                    const term = Math.sqrt(1 + (y * y) / (b * b));
                    const x = a * term; 

                    if (Math.abs(x) < CONFIG.planeSize / 1.9) {
                        points.push(new THREE.Vector3(x, 0.03, -y)); // y=0.03 è²¼åœ°
                    }
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: color, linewidth: 2, transparent: true, opacity: 0.9 });
                const line = new THREE.Line(geometry, material);
                analysisGroup.add(line);
            };

            const maxOrder = Math.ceil(d / lambda) + 1;

            // 1. è…¹ç·š (n * lambda)
            for (let n = -maxOrder; n <= maxOrder; n++) {
                drawHyperbola(n * lambda, 0xff3333);
            }

            // 2. ç¯€ç·š ((n - 0.5) * lambda)
            for (let n = -maxOrder; n <= maxOrder; n++) {
                drawHyperbola((n - 0.5) * lambda, 0xffdd00);
            }
        }

        // --- ç¹ªåœ–é‚è¼¯ (æ³¢å‰) ---
        function updateWavefronts() {
            while(wavefrontGroup.children.length > 0) {
                const child = wavefrontGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                wavefrontGroup.remove(child);
            }
            sources.forEach(src => {
                const t = state.virtualTime - src.start;
                if (t <= 0) return;
                let phaseShift = (state.mode === 'interference' && src.id === 2) ? state.phaseOffset : 0;
                let r0 = (t * CONFIG.waveSpeed) % WAVELENGTH;
                if (phaseShift !== 0) { r0 -= (phaseShift / (2*Math.PI)) * WAVELENGTH; while(r0 < 0) r0 += WAVELENGTH; }
                const maxDist = t * CONFIG.waveSpeed;
                for (let r = r0; r < 50; r += WAVELENGTH) {
                    if (r < 1) continue; if (r > maxDist) break;
                    const curve = new THREE.EllipseCurve(0, 0, r, r, 0, 2*Math.PI, false, 0);
                    const pts = curve.getPoints(60);
                    const geo = new THREE.BufferGeometry().setFromPoints(pts);
                    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                    const line = new THREE.Line(geo, mat);
                    line.rotation.x = -Math.PI/2; line.position.set(src.x, 0, -src.y); 
                    wavefrontGroup.add(line);
                }
            });
        }

        function performMeasurement(point) {
            clickedPoint = point; clearMeasurement(); clearLabels();
            const s1 = sources[0]; const s2 = sources[1];
            drawLine(s1, point, 0xff00ff); drawLine(s2, point, 0xff00ff);
            const geo = new THREE.SphereGeometry(0.5, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(point.x, 0.5, -point.y); measurementGroup.add(mesh);
            const ps1 = Math.sqrt((point.x - s1.x)**2 + (point.y - s1.y)**2);
            const ps2 = Math.sqrt((point.x - s2.x)**2 + (point.y - s2.y)**2);
            const deltaL = Math.abs(ps1 - ps2);
            const ratio = deltaL / WAVELENGTH;
            document.getElementById('res-ps1').innerText = ps1.toFixed(1);
            document.getElementById('res-ps2').innerText = ps2.toFixed(1);
            document.getElementById('res-delta').innerText = deltaL.toFixed(1);
            document.getElementById('res-n').innerText = ratio.toFixed(2);
            const distCorrection = (state.phaseOffset / (2*Math.PI)) * WAVELENGTH;
            const effectiveDiff = deltaL - distCorrection;
            const rem = Math.abs(effectiveDiff % WAVELENGTH);
            const tag = document.getElementById('res-tag');
            if (rem < 0.2 || Math.abs(rem - WAVELENGTH) < 0.2) { tag.innerText = "å»ºè¨­æ€§å¹²æ¶‰ (è…¹é») - äº®ç´‹"; tag.className = "result-tag tag-constructive"; } 
            else if (Math.abs(rem - 0.5 * WAVELENGTH) < 0.2) { tag.innerText = "ç ´å£æ€§å¹²æ¶‰ (ç¯€é») - æš—ç´‹"; tag.className = "result-tag tag-destructive"; } 
            else { tag.innerText = "ä¸€èˆ¬å¹²æ¶‰é»"; tag.className = "result-tag tag-normal"; }
            createLabel((s1.x + point.x)/2, -(s1.y + point.y)/2, ps1.toFixed(1));
            createLabel((s2.x + point.x)/2, -(s2.y + point.y)/2, ps2.toFixed(1));
        }
        function drawLine(src, pt, color) {
            const points = []; points.push(new THREE.Vector3(src.x, 1, -src.y)); points.push(new THREE.Vector3(pt.x, 0.5, -pt.y));
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            const line = new THREE.Line(geo, mat); measurementGroup.add(line);
        }
        function createLabel(x, z, text) {
            const div = document.createElement('div'); div.className = 'label-marker'; div.innerText = text; div.dataset.x = x; div.dataset.z = z;
            document.getElementById('labels-container').appendChild(div);
        }
        function clearLabels() { document.getElementById('labels-container').innerHTML = ''; }
        function updateLabelsPosition() {
            const labels = document.querySelectorAll('.label-marker');
            labels.forEach(label => {
                const x = parseFloat(label.dataset.x); const z = parseFloat(label.dataset.z);
                const vector = new THREE.Vector3(x, 1, z); vector.project(camera);
                const px = (vector.x * .5 + .5) * window.innerWidth; const py = (-(vector.y * .5) + .5) * window.innerHeight;
                if (vector.z > 1) label.style.display = 'none'; else { label.style.display = 'block'; label.style.left = `${px}px`; label.style.top = `${py}px`; }
            });
        }
        function resetSim() {
            sources = []; state.virtualTime = 0; 
            while(markersGroup.children.length > 0) markersGroup.remove(markersGroup.children[0]);
            while(wavefrontGroup.children.length > 0) wavefrontGroup.remove(wavefrontGroup.children[0]);
            while(analysisGroup.children.length > 0) analysisGroup.remove(analysisGroup.children[0]);
            while(measurementGroup.children.length > 0) measurementGroup.remove(measurementGroup.children[0]);
            clearMeasurement();
            const pos = waterGeo.attributes.position; for(let i=0; i<pos.count; i++) pos.setZ(i, 0); pos.needsUpdate = true;
            if (state.mode === 'interference') { setupInterferenceSources(); if(document.getElementById('val-ratio')) updateInfoPanelData(); if(state.showAnalysis) drawAnalysisLines(); }
        }
        function setupInterferenceSources() {
            const spacing = CONFIG.sourceSpacing / 2;
            sources.push({ x: -spacing, y: 0, start: 0, type: 'continuous', id: 1 });
            sources.push({ x: spacing,  y: 0, start: 0, type: 'continuous', id: 2 });
            addMarker(-spacing, 0); addMarker(spacing, 0);
        }
        function addMarker(x, y) {
            const geo = new THREE.SphereGeometry(1.2, 32, 32); const mat = new THREE.MeshLambertMaterial({ color: 0xffaa00, emissive: 0xff4400, emissiveIntensity: 0.8 });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, 2.5, -y); markersGroup.add(mesh);
        }
        function updateSeparation(val) { CONFIG.sourceSpacing = parseFloat(val); if(state.mode==='interference') { document.getElementById('val-d').innerText = CONFIG.sourceSpacing.toFixed(1); resetSim(); } }
        function updatePhase(val) { document.getElementById('phase-val').innerText = val + "Â°"; state.phaseOffset = (val * Math.PI) / 180; if(state.showAnalysis) drawAnalysisLines(); if(clickedPoint) performMeasurement(clickedPoint); }
        function onWaterClick(event) {
            if (event.target.closest('.ui-panel')) return;
            const mouse = new THREE.Vector2(); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(waterMesh);
            if (intersects.length > 0) {
                const p = intersects[0].point; const physicsPt = { x: p.x, y: -p.z };
                if (state.mode === 'single') { sources.push({ x: physicsPt.x, y: physicsPt.y, start: state.virtualTime, type: 'pulse', id: 0 }); if (sources.length > 6) sources.shift(); } 
                else if (state.mode === 'interference' && state.pathDiffMode) { performMeasurement(physicsPt); }
            }
        }
        function togglePause() { state.paused = !state.paused; const btn = document.getElementById('btn-pause'); btn.innerHTML = state.paused ? "â–¶ ç¹¼çºŒ" : "â¸ æš«åœ"; btn.className = state.paused ? "active" : "warning"; }
        function toggleSlow() { state.slowMotion = !state.slowMotion; document.getElementById('btn-slow').className = state.slowMotion ? "active" : ""; }
        function updateToggleBtn(id, isOn) { const btn = document.getElementById(id); if(!btn) return; const status = btn.querySelector('.status'); if (isOn) { btn.classList.add('on'); status.innerText = "é–‹å•Ÿ"; } else { btn.classList.remove('on'); status.innerText = "é—œé–‰"; } }
        function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        init();
    </script>
</body>
</html>