<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é«˜ä¸­ç‰©ç†ï¼šæ³¢å‹•å¯¦é©—å®¤ (æ‰‹æ©Ÿæ©«å‘å„ªåŒ–ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; }
        
        /* === 1. ç›´å‘ä½¿ç”¨æ™‚çš„é˜»æ“‹é®ç½© === */
        #orientation-warning {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(26, 26, 26, 0.95);
            z-index: 9999;
            display: none; /* é è¨­éš±è— */
            flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center;
            backdrop-filter: blur(10px);
        }
        #orientation-warning .icon { font-size: 3rem; margin-bottom: 20px; animation: rotatePhone 2s infinite; }
        #orientation-warning h2 { color: #fff; border: none; margin-bottom: 10px; }
        
        @keyframes rotatePhone {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(-90deg); }
            100% { transform: rotate(-90deg); }
        }

        /* CSS Media Query: åµæ¸¬ç›´å‘ (Portrait) */
        @media screen and (orientation: portrait) {
            #orientation-warning { display: flex; } /* é¡¯ç¤ºè­¦å‘Š */
            #ui-left, #ui-right, #labels-container { display: none !important; } /* éš±è—ä»‹é¢ */
        }

        /* === 2. ä»‹é¢é¢æ¿æ¨£å¼ === */
        .ui-panel {
            position: absolute; top: 15px; 
            background: rgba(255, 255, 255, 0.96);
            border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; overflow: hidden;
            transition: all 0.3s ease;
            z-index: 10;
        }

        /* å·¦å´æ§åˆ¶é¢æ¿ */
        #ui-left { left: 15px; width: 300px; max-height: 90vh; }
        
        /* å³å´è³‡è¨Šé¢æ¿ */
        #ui-right { right: 15px; width: 340px; max-height: 90vh; }

        /* æ‰‹æ©Ÿæ©«å‘å„ªåŒ–ï¼šå¦‚æœè¢å¹•é«˜åº¦å°æ–¼ 500px (é€šå¸¸æ˜¯æ‰‹æ©Ÿæ©«æ”¾) */
        @media screen and (max-height: 500px) {
            .ui-panel { max-height: 85vh; } /* é¿å…å¤ªæ»¿ */
            #ui-left, #ui-right { width: 260px; } /* å¯¬åº¦ç¸®å°ä¸€é» */
            .header { height: 40px; padding: 0 10px; }
            h2 { font-size: 1rem; }
            button { padding: 6px; font-size: 0.85rem; }
            .ui-content { padding: 10px; }
            /* å¦‚æœè¢å¹•çœŸçš„å¾ˆçª„ï¼Œç¢ºä¿é¢æ¿ä¸æœƒé‡ç–Šï¼Œè¨­æœ€å¤§å¯¬åº¦ */
            #ui-left, #ui-right { max-width: 45vw; }
        }

        /* æ”¶èµ·ç‹€æ…‹ */
        .ui-panel.collapsed { height: 40px !important; overflow: hidden; } /* æ‰‹æ©Ÿç‰ˆæ¨™é¡Œè®ŠçŸ® */
        .ui-panel.collapsed .ui-content { display: none; }

        /* æ¨™é¡Œåˆ— */
        .header {
            padding: 0 15px; background: #f8f9fa; border-bottom: 3px solid #0056b3;
            display: flex; justify-content: space-between; align-items: center;
            height: 50px; box-sizing: border-box; flex-shrink: 0;
        }
        h2 { margin: 0; color: #0056b3; font-size: 1.1rem; font-weight: 700; }
        
        /* æ”¶èµ·æŒ‰éˆ• (å®Œç¾è²¼åˆç‰ˆ) */
        .toggle-collapse-btn {
            background: none; border: none; padding: 4px; color: #666;
            cursor: pointer; font-size: 0.9rem; width: auto; white-space: nowrap;
        }
        .toggle-collapse-btn:hover { color: #0056b3; text-decoration: underline; }

        /* å…§å®¹å€ */
        .ui-content { padding: 15px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        
        .section-title { 
            font-size: 0.9rem; font-weight: bold; color: #444; 
            margin: 10px 0 8px 0; text-transform: uppercase; letter-spacing: 1px; 
            border-bottom: 1px solid #eee; padding-bottom: 4px;
        }

        /* æŒ‰éˆ•ç¾¤çµ„ */
        .btn-group { display: flex; gap: 8px; margin-bottom: 10px; }
        button {
            flex: 1; padding: 10px; border: none; border-radius: 6px;
            background: #e9ecef; color: #333; cursor: pointer; font-weight: 600; font-size: 0.9rem;
            transition: 0.2s; touch-action: manipulation; /* å„ªåŒ–è§¸æ§ */
        }
        button:hover { background: #dbe2e8; }
        button.active { background: #007bff; color: white; }
        button.warning { background: #ffc107; color: #333; }
        button.purple { background: #6f42c1; color: white; }
        
        /* åŠŸèƒ½é–‹é—œ */
        .toggle-btn { display: flex; justify-content: space-between; align-items: center; width: 100%; text-align: left; margin-bottom: 5px;}
        .toggle-btn span.status { font-size: 0.8rem; background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px; }
        .toggle-btn.on { background: #28a745; color: white; }
        .toggle-btn.on span.status { background: rgba(255,255,255,0.3); }
        .toggle-btn.measure.on { background: #6f42c1; }

        .control-box { background: #fff9db; padding: 12px; border-radius: 8px; margin-top: 8px; border: 1px solid #ffe066; }
        .slider-row { margin-bottom: 10px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 4px; font-weight: 600; color: #444; }
        input[type=range] { width: 100%; cursor: pointer; }

        /* æŠ˜ç–Šå…¬å¼ */
        details { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; margin-bottom: 10px; }
        summary { padding: 10px; cursor: pointer; font-weight: bold; color: #495057; outline: none; }
        .formula-content { padding: 10px; border-top: 1px solid #eee; }
        .formula-line { font-family: 'Times New Roman', serif; font-size: 1.05rem; margin-bottom: 8px; color: #222; }
        .formula-desc { font-size: 0.85rem; color: #666; font-family: sans-serif; margin-left: 5px; }

        /* æ•¸æ“šè¡¨æ ¼ */
        .data-table { width: 100%; border-collapse: collapse; margin-top: 5px; }
        .data-table td { padding: 5px 0; border-bottom: 1px dashed #eee; font-size: 0.9rem; }
        .data-val { font-weight: bold; color: #0056b3; font-family: monospace; font-size: 1.1rem; float: right;}

        /* æ³¢ç¨‹å·®çµæœ */
        #path-diff-result { margin-top: 15px; padding: 10px; border-radius: 8px; background: #f3e5f5; border: 1px solid #e1bee7; display: none; }
        .result-tag { display: block; text-align: center; font-weight: bold; color: white; padding: 5px; border-radius: 4px; margin-top: 5px; }
        .tag-constructive { background: #d9534f; }
        .tag-destructive { background: #f0ad4e; }
        .tag-normal { background: #6c757d; }

        /* æµ®å‹•æ¨™ç±¤ */
        .label-marker {
            position: absolute; background: rgba(255,255,255,0.9); padding: 2px 6px;
            border-radius: 4px; border: 1px solid #ccc; font-size: 0.8rem; font-weight: bold;
            color: #333; pointer-events: none; transform: translate(-50%, -50%); z-index: 5;
            white-space: nowrap;
        }

        .guide-box { background: #e7f5ff; padding: 15px; border-radius: 8px; font-size: 0.95rem; line-height: 1.6; color: #004085; border-left: 5px solid #007bff; }
        .mode-specific { display: block; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="orientation-warning">
        <div class="icon">ğŸ“±</div>
        <h2>è«‹æ©«å‘ä½¿ç”¨è£ç½®</h2>
        <p>ç‚ºäº†ç²å¾—æœ€ä½³çš„å¯¦é©—æ“ä½œé«”é©—ï¼Œ<br>è«‹å°‡æ‚¨çš„æ‰‹æ©Ÿæˆ–å¹³æ¿æ—‹è½‰è‡³æ©«å‘ã€‚</p>
    </div>

    <div id="labels-container"></div>

    <div id="ui-left" class="ui-panel">
        <div class="header">
            <h2>ğŸŒŠ æ³¢å‹•å¯¦é©—å®¤</h2>
            <button class="toggle-collapse-btn" onclick="togglePanel('ui-left', this)">æ”¶èµ·</button>
        </div>
        <div id="ui-content-left" class="ui-content">
            <div class="section-title">å¯¦é©—æ¨¡å¼</div>
            <div class="btn-group">
                <button id="btn-single" onclick="setMode('single')">å–®æ³¢æº</button>
                <button id="btn-interference" onclick="setMode('interference')">é›™æ³¢æºå¹²æ¶‰</button>
            </div>

            <div id="group-single" class="mode-specific">
                 <button id="btn-wavefront-single" class="toggle-btn" onclick="toggleWavefronts()">
                    <span>â­• é¡¯ç¤ºæ³¢å‰ (ç´”å¹¾ä½•)</span><span class="status">é—œé–‰</span>
                </button>
            </div>

            <div id="group-interference" class="mode-specific hidden">
                <div class="control-box">
                    <div class="slider-row">
                        <div class="slider-label">
                            <span>æ³¢æºè·é›¢ (d)</span>
                            <span id="dist-val">12.0</span>
                        </div>
                        <input type="range" min="6" max="24" value="12" step="0.5" oninput="updateSeparation(this.value)">
                    </div>
                    <div class="slider-row">
                        <div class="slider-label">
                            <span>ç›¸ä½å·® (Phase)</span>
                            <span id="phase-val">0Â°</span>
                        </div>
                        <input type="range" min="0" max="180" value="0" step="15" oninput="updatePhase(this.value)">
                    </div>
                </div>

                <div style="margin-top:10px;">
                    <button id="btn-path-diff" class="toggle-btn measure" onclick="togglePathDiffMode()">
                        <span>ğŸ“ æ¸¬é‡æ³¢ç¨‹å·®</span><span class="status">é—œé–‰</span>
                    </button>
                    <button id="btn-wavefront-int" class="toggle-btn" onclick="toggleWavefronts()">
                        <span>â­• é¡¯ç¤ºæ³¢å‰ (ç´”å¹¾ä½•)</span><span class="status">é—œé–‰</span>
                    </button>
                    <button id="btn-analysis" class="toggle-btn" onclick="toggleAnalysis()">
                        <span>ğŸ“Š é¡¯ç¤ºç¯€ç·šèˆ‡è…¹ç·š</span><span class="status">é—œé–‰</span>
                    </button>
                </div>
            </div>

            <div class="section-title">æ™‚é–“æ§åˆ¶</div>
            <div class="btn-group">
                <button id="btn-pause" class="warning" onclick="togglePause()">â¸ æš«åœ</button>
                <button id="btn-slow" onclick="toggleSlow()">ğŸ¢ æ…¢å‹•ä½œ</button>
                <button onclick="resetSim()" style="background:#6c757d; color:white;">â†º é‡ç½®</button>
            </div>
        </div>
    </div>

    <div id="ui-right" class="ui-panel">
        <div class="header">
            <h2>ğŸ“ æ•¸æ“šèˆ‡å…¬å¼</h2>
            <button class="toggle-collapse-btn" onclick="togglePanel('ui-right', this)">æ”¶èµ·</button>
        </div>
        <div id="ui-content-right" class="ui-content">
            </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- ç‰©ç†åƒæ•¸ ---
        const CONFIG = {
            gridSize: 70,
            planeSize: 60,
            waveSpeed: 3.0,
            waveFreq: 1.0,
            amplitude: 1.5,
            sourceSpacing: 12
        };
        let WAVELENGTH = CONFIG.waveSpeed / CONFIG.waveFreq;

        // --- å…¨åŸŸè®Šæ•¸ ---
        let scene, camera, renderer, controls;
        let waterMesh, waterGeo;
        let clock = new THREE.Clock();
        
        let state = {
            mode: 'single', 
            paused: false,
            slowMotion: false,
            showWavefronts: false, 
            showAnalysis: false,
            pathDiffMode: false,
            phaseOffset: 0,
            virtualTime: 0
        };

        let sources = [];
        let markersGroup, wavefrontGroup, analysisGroup, measurementGroup;
        let clickedPoint = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xaaccff);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 65, 50); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(30, 50, 30);
            sun.castShadow = true;
            sun.shadow.camera.left = -40; sun.shadow.camera.right = 40;
            sun.shadow.camera.top = 40; sun.shadow.camera.bottom = -40;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            waterGeo = new THREE.PlaneGeometry(CONFIG.planeSize, CONFIG.planeSize, CONFIG.gridSize, CONFIG.gridSize);
            const waterMat = new THREE.MeshPhongMaterial({ 
                color: 0x0077be, shininess: 100, specular: 0x111111,
                side: THREE.DoubleSide, flatShading: false, transparent: true, opacity: 0.9
            });
            waterMesh = new THREE.Mesh(waterGeo, waterMat);
            waterMesh.rotation.x = -Math.PI / 2;
            waterMesh.receiveShadow = true;
            scene.add(waterMesh);

            markersGroup = new THREE.Group(); scene.add(markersGroup); 
            wavefrontGroup = new THREE.Group(); scene.add(wavefrontGroup); 
            analysisGroup = new THREE.Group(); scene.add(analysisGroup); 
            measurementGroup = new THREE.Group(); scene.add(measurementGroup); 

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;

            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('pointerdown', onWaterClick);

            setMode('single');
            animate();
        }

        function togglePanel(panelId, btn) {
            const panel = document.getElementById(panelId);
            panel.classList.toggle('collapsed');
            btn.innerText = panel.classList.contains('collapsed') ? 'å±•é–‹' : 'æ”¶èµ·';
        }

        function setMode(modeName) {
            state.mode = modeName;
            document.getElementById('btn-single').className = modeName === 'single' ? 'active' : '';
            document.getElementById('btn-interference').className = modeName === 'interference' ? 'active' : '';
            document.getElementById('group-single').classList.toggle('hidden', modeName !== 'single');
            document.getElementById('group-interference').classList.toggle('hidden', modeName !== 'interference');
            
            state.showWavefronts = false;
            state.showAnalysis = false;
            state.pathDiffMode = false;
            clickedPoint = null;
            clearLabels();

            updateToggleBtn('btn-wavefront-single', false);
            updateToggleBtn('btn-wavefront-int', false);
            updateToggleBtn('btn-analysis', false);
            updateToggleBtn('btn-path-diff', false);

            resetSim(); 
            updateRightPanel(); 
        }

        function updateRightPanel() {
            const contentDiv = document.getElementById('ui-content-right');
            if (state.mode === 'single') {
                contentDiv.innerHTML = `
                    <div class="section-title">ğŸ“˜ å­¸ç¿’å¼•å°</div>
                    <div class="guide-box">
                        <p><b>å¯¦é©—ç›®æ¨™ï¼š</b><br>è§€å¯Ÿæ³¢çš„å‚³éèˆ‡ã€Œæ³¢å‰ã€çš„å®šç¾©ã€‚</p>
                        <div style="border-top:1px dashed #aaddff; margin:10px 0;"></div>
                        <p><b>æ³¢å‰ (Wavefront)</b><br>
                        é–‹å•Ÿã€Œé¡¯ç¤ºæ³¢å‰ã€å¾Œï¼Œç•«é¢å°‡åˆ‡æ›ç‚ºå¹¾ä½•æ¨¡å¼ã€‚<br>
                        ç™½è‰²åœ“åœˆä»£è¡¨<b>æ³¢å³°</b>çš„é€£ç·šã€‚</p>
                    </div>
                `;
            } else {
                contentDiv.innerHTML = `
                    <details open>
                        <summary>1. æ³¢ç¨‹å·®å…¬å¼</summary>
                        <div class="formula-content">
                            <div class="formula-line">PS<sub>1</sub> - PS<sub>2</sub> = nÎ» <span class="formula-desc">(è…¹ç·š)</span></div>
                            <div class="formula-line">PS<sub>1</sub> - PS<sub>2</sub> = (n - 0.5)Î» <span class="formula-desc">(ç¯€ç·š)</span></div>
                        </div>
                    </details>
                    <details>
                        <summary>2. ç¯€ç·šæ•¸é‡å…¬å¼</summary>
                        <div class="formula-content">
                            <div class="formula-line">N = 2n <span class="formula-desc">(ç¸½æ•¸)</span></div>
                            <div class="formula-line" style="font-size:0.9rem;">æ¨å°ï¼š n â‰¤ d/Î» + 1/2</div>
                        </div>
                    </details>
                    <div class="section-title">3. å¯¦é©—æ•¸æ“š</div>
                    <table class="data-table">
                        <tr><td>æ³¢é•· (Î»)</td><td><span class="data-val">${WAVELENGTH.toFixed(1)}</span></td></tr>
                        <tr><td>æ³¢æºè·é›¢ (d)</td><td><span class="data-val" id="val-d">${CONFIG.sourceSpacing.toFixed(1)}</span></td></tr>
                        <tr style="background:#fff9c4;"><td><strong>æ¯”å€¼ (d / Î»)</strong></td><td><span class="data-val" id="val-ratio">--</span></td></tr>
                    </table>
                    <div id="path-diff-result">
                        <div style="font-weight:bold; color:#6f42c1; margin-bottom:5px;">ğŸ“ æ³¢ç¨‹å·®æ¸¬é‡</div>
                        <table class="data-table">
                            <tr><td>PS<sub>1</sub></td><td><span class="data-val" id="res-ps1">--</span></td></tr>
                            <tr><td>PS<sub>2</sub></td><td><span class="data-val" id="res-ps2">--</span></td></tr>
                            <tr><td><strong>Î”L</strong></td><td><span class="data-val" id="res-delta">--</span></td></tr>
                            <tr><td>Î”L / Î»</td><td><span class="data-val" id="res-n">--</span></td></tr>
                        </table>
                        <div id="res-tag" class="result-tag tag-normal">è«‹é»æ“Šæ°´é¢</div>
                    </div>
                `;
                updateInfoPanelData();
            }
        }

        function updateInfoPanelData() {
            const d = CONFIG.sourceSpacing;
            const lambda = WAVELENGTH;
            const ratio = d / lambda;
            const elRatio = document.getElementById('val-ratio');
            if(elRatio) {
                document.getElementById('val-d').innerText = d.toFixed(1);
                elRatio.innerText = ratio.toFixed(2);
            }
        }

        function togglePathDiffMode() {
            if(state.mode !== 'interference') return;
            state.pathDiffMode = !state.pathDiffMode;
            updateToggleBtn('btn-path-diff', state.pathDiffMode);
            const resBox = document.getElementById('path-diff-result');
            if (state.pathDiffMode) {
                resBox.style.display = 'block';
                if(!state.paused) togglePause(); 
            } else {
                resBox.style.display = 'none';
                clearMeasurement();
                if(state.paused) togglePause();
            }
        }

        function clearMeasurement() {
            clickedPoint = null; clearLabels();
            while(measurementGroup.children.length > 0) measurementGroup.remove(measurementGroup.children[0]);
        }

        function toggleWavefronts() {
            state.showWavefronts = !state.showWavefronts;
            updateToggleBtn('btn-wavefront-single', state.showWavefronts);
            updateToggleBtn('btn-wavefront-int', state.showWavefronts);
            if(!state.showWavefronts) {
                while(wavefrontGroup.children.length > 0) {
                    const child = wavefrontGroup.children[0];
                    if(child.geometry) child.geometry.dispose();
                    wavefrontGroup.remove(child);
                }
            }
        }

        function toggleAnalysis() {
            state.showAnalysis = !state.showAnalysis;
            updateToggleBtn('btn-analysis', state.showAnalysis);
            if(state.showAnalysis) { drawAnalysisLines(); } else {
                while(analysisGroup.children.length > 0) {
                    const child = analysisGroup.children[0];
                    if(child.geometry) child.geometry.dispose();
                    analysisGroup.remove(child);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (!state.paused) {
                const timeStep = state.slowMotion ? dt * 0.2 : dt;
                state.virtualTime += timeStep;
                updateWaterPhysics();
            }
            if (state.showWavefronts) updateWavefronts();
            if (markersGroup.visible && markersGroup.children.length === 2) { 
                markersGroup.children[0].position.y = 2.5 + Math.sin(state.virtualTime * 5) * 0.5;
                markersGroup.children[1].position.y = 2.5 + Math.sin(state.virtualTime * 5 + state.phaseOffset) * 0.5;
            }
            waterMesh.visible = !state.showWavefronts;
            markersGroup.visible = !state.showWavefronts;
            updateLabelsPosition();
            controls.update();
            renderer.render(scene, camera);
        }

        function updateWavefronts() {
            while(wavefrontGroup.children.length > 0) {
                const child = wavefrontGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                wavefrontGroup.remove(child);
            }
            sources.forEach(src => {
                const t = state.virtualTime - src.start;
                if (t <= 0) return;
                let phaseShift = (state.mode === 'interference' && src.id === 2) ? state.phaseOffset : 0;
                let r0 = (t * CONFIG.waveSpeed) % WAVELENGTH;
                if (phaseShift !== 0) { r0 -= (phaseShift / (2*Math.PI)) * WAVELENGTH; while(r0 < 0) r0 += WAVELENGTH; }
                const maxDist = t * CONFIG.waveSpeed;
                for (let r = r0; r < 50; r += WAVELENGTH) {
                    if (r < 1) continue; if (r > maxDist) break;
                    const curve = new THREE.EllipseCurve(0, 0, r, r, 0, 2*Math.PI, false, 0);
                    const pts = curve.getPoints(60);
                    const geo = new THREE.BufferGeometry().setFromPoints(pts);
                    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                    const line = new THREE.Line(geo, mat);
                    line.rotation.x = -Math.PI/2; line.position.set(src.x, 0.5, -src.y); 
                    wavefrontGroup.add(line);
                }
            });
        }

        function drawAnalysisLines() {
            while(analysisGroup.children.length > 0) {
                const child = analysisGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                analysisGroup.remove(child);
            }
            if (!state.showAnalysis || state.mode === 'single' || sources.length < 2) return;
            const s1 = sources[0]; const s2 = sources[1];
            const pointsNode = []; const pointsAnti = [];
            const distCorrection = (state.phaseOffset / (2*Math.PI)) * WAVELENGTH;
            for (let x = -30; x <= 30; x += 0.3) {
                for (let y = -30; y <= 30; y += 0.3) {
                    const d1 = Math.sqrt((x - s1.x)**2 + (y - s1.y)**2);
                    const d2 = Math.sqrt((x - s2.x)**2 + (y - s2.y)**2);
                    let pathDiff = (d1 - d2) - distCorrection;
                    let rem = Math.abs(pathDiff % WAVELENGTH);
                    if (rem < 0.2 || Math.abs(rem - WAVELENGTH) < 0.2) pointsAnti.push(x, 0.8, -y);
                    let ratio = Math.abs(pathDiff / WAVELENGTH);
                    let decimal = ratio - Math.floor(ratio);
                    if (Math.abs(decimal - 0.5) < 0.08) pointsNode.push(x, 0.8, -y);
                }
            }
            createPoints(pointsAnti, 0xff3333, analysisGroup); createPoints(pointsNode, 0xffdd00, analysisGroup);
        }

        function createPoints(coords, color, group) {
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(coords, 3));
            const mat = new THREE.PointsMaterial({ color: color, size: 0.25, sizeAttenuation: true });
            const pts = new THREE.Points(geo, mat);
            group.add(pts);
        }

        function performMeasurement(point) {
            clickedPoint = point; clearMeasurement(); clearLabels();
            const s1 = sources[0]; const s2 = sources[1];
            drawLine(s1, point, 0xff00ff); drawLine(s2, point, 0xff00ff);
            const geo = new THREE.SphereGeometry(0.5, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(point.x, 0.5, -point.y); measurementGroup.add(mesh);
            const ps1 = Math.sqrt((point.x - s1.x)**2 + (point.y - s1.y)**2);
            const ps2 = Math.sqrt((point.x - s2.x)**2 + (point.y - s2.y)**2);
            const deltaL = Math.abs(ps1 - ps2);
            const ratio = deltaL / WAVELENGTH;
            document.getElementById('res-ps1').innerText = ps1.toFixed(1);
            document.getElementById('res-ps2').innerText = ps2.toFixed(1);
            document.getElementById('res-delta').innerText = deltaL.toFixed(1);
            document.getElementById('res-n').innerText = ratio.toFixed(2);
            const distCorrection = (state.phaseOffset / (2*Math.PI)) * WAVELENGTH;
            const effectiveDiff = deltaL - distCorrection;
            const rem = Math.abs(effectiveDiff % WAVELENGTH);
            const tag = document.getElementById('res-tag');
            if (rem < 0.2 || Math.abs(rem - WAVELENGTH) < 0.2) { tag.innerText = "å»ºè¨­æ€§å¹²æ¶‰ (è…¹é»)"; tag.className = "result-tag tag-constructive"; } 
            else if (Math.abs(rem - 0.5 * WAVELENGTH) < 0.2) { tag.innerText = "ç ´å£æ€§å¹²æ¶‰ (ç¯€é»)"; tag.className = "result-tag tag-destructive"; } 
            else { tag.innerText = "ä¸€èˆ¬å¹²æ¶‰é»"; tag.className = "result-tag tag-normal"; }
            createLabel((s1.x + point.x)/2, -(s1.y + point.y)/2, ps1.toFixed(1));
            createLabel((s2.x + point.x)/2, -(s2.y + point.y)/2, ps2.toFixed(1));
        }
        function drawLine(src, pt, color) {
            const points = []; points.push(new THREE.Vector3(src.x, 1, -src.y)); points.push(new THREE.Vector3(pt.x, 0.5, -pt.y));
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            const line = new THREE.Line(geo, mat); measurementGroup.add(line);
        }
        function createLabel(x, z, text) {
            const div = document.createElement('div'); div.className = 'label-marker'; div.innerText = text; div.dataset.x = x; div.dataset.z = z;
            document.getElementById('labels-container').appendChild(div);
        }
        function clearLabels() { document.getElementById('labels-container').innerHTML = ''; }
        function updateLabelsPosition() {
            const labels = document.querySelectorAll('.label-marker');
            labels.forEach(label => {
                const x = parseFloat(label.dataset.x); const z = parseFloat(label.dataset.z);
                const vector = new THREE.Vector3(x, 1, z); vector.project(camera);
                const px = (vector.x * .5 + .5) * window.innerWidth; const py = (-(vector.y * .5) + .5) * window.innerHeight;
                if (vector.z > 1) label.style.display = 'none'; else { label.style.display = 'block'; label.style.left = `${px}px`; label.style.top = `${py}px`; }
            });
        }
        function updateWaterPhysics() {
            const pos = waterGeo.attributes.position; const k = CONFIG.waveFreq; const w = CONFIG.waveSpeed * k;
            for (let i = 0; i < pos.count; i++) {
                let x = pos.getX(i); let y = pos.getY(i); let z = 0;
                for (let src of sources) {
                    const dist = Math.sqrt((x - src.x)**2 + (y - src.y)**2);
                    const t = state.virtualTime - src.start;
                    if (t > 0) {
                        let phase = dist * k - t * w;
                        if (state.mode === 'interference' && src.id === 2) phase += state.phaseOffset;
                        let damping = Math.exp(-0.02 * dist);
                        if (src.type === 'pulse') {
                            let center = t * CONFIG.waveSpeed; let pulse = Math.exp(-Math.pow(dist - center, 2) / 15);
                            z += Math.sin(phase) * CONFIG.amplitude * pulse;
                        } else { if (dist < 3) damping *= (dist/3); z += Math.sin(phase) * CONFIG.amplitude * damping; }
                    }
                }
                pos.setZ(i, z);
            }
            pos.needsUpdate = true; waterGeo.computeVertexNormals();
        }
        function resetSim() {
            sources = []; state.virtualTime = 0; 
            while(markersGroup.children.length > 0) markersGroup.remove(markersGroup.children[0]);
            while(wavefrontGroup.children.length > 0) wavefrontGroup.remove(wavefrontGroup.children[0]);
            while(analysisGroup.children.length > 0) analysisGroup.remove(analysisGroup.children[0]);
            while(measurementGroup.children.length > 0) measurementGroup.remove(measurementGroup.children[0]);
            clearMeasurement();
            const pos = waterGeo.attributes.position; for(let i=0; i<pos.count; i++) pos.setZ(i, 0); pos.needsUpdate = true;
            if (state.mode === 'interference') { setupInterferenceSources(); if(document.getElementById('val-ratio')) updateInfoPanelData(); if(state.showAnalysis) drawAnalysisLines(); }
        }
        function setupInterferenceSources() {
            const spacing = CONFIG.sourceSpacing / 2;
            sources.push({ x: -spacing, y: 0, start: 0, type: 'continuous', id: 1 });
            sources.push({ x: spacing,  y: 0, start: 0, type: 'continuous', id: 2 });
            addMarker(-spacing, 0); addMarker(spacing, 0);
        }
        function addMarker(x, y) {
            const geo = new THREE.SphereGeometry(1.2, 32, 32); const mat = new THREE.MeshLambertMaterial({ color: 0xffaa00, emissive: 0xff4400, emissiveIntensity: 0.8 });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, 2.5, -y); markersGroup.add(mesh);
        }
        function updateSeparation(val) { CONFIG.sourceSpacing = parseFloat(val); if(state.mode==='interference') { document.getElementById('val-d').innerText = CONFIG.sourceSpacing.toFixed(1); resetSim(); } }
        function updatePhase(val) { document.getElementById('phase-val').innerText = val + "Â°"; state.phaseOffset = (val * Math.PI) / 180; if(state.showAnalysis) drawAnalysisLines(); if(clickedPoint) performMeasurement(clickedPoint); }
        function onWaterClick(event) {
            if (event.target.closest('.ui-panel')) return;
            const mouse = new THREE.Vector2(); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(waterMesh);
            if (intersects.length > 0) {
                const p = intersects[0].point; const physicsPt = { x: p.x, y: -p.z };
                if (state.mode === 'single') { sources.push({ x: physicsPt.x, y: physicsPt.y, start: state.virtualTime, type: 'pulse', id: 0 }); if (sources.length > 6) sources.shift(); } 
                else if (state.mode === 'interference' && state.pathDiffMode) { performMeasurement(physicsPt); }
            }
        }
        function togglePause() { state.paused = !state.paused; const btn = document.getElementById('btn-pause'); btn.innerHTML = state.paused ? "â–¶ ç¹¼çºŒ" : "â¸ æš«åœ"; btn.className = state.paused ? "active" : "warning"; }
        function toggleSlow() { state.slowMotion = !state.slowMotion; document.getElementById('btn-slow').className = state.slowMotion ? "active" : ""; }
        function updateToggleBtn(id, isOn) { const btn = document.getElementById(id); if(!btn) return; const status = btn.querySelector('.status'); if (isOn) { btn.classList.add('on'); status.innerText = "é–‹å•Ÿ"; } else { btn.classList.remove('on'); status.innerText = "é—œé–‰"; } }
        function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        init();
    </script>
</body>
</html>