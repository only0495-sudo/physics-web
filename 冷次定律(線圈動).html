<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†·æ¬¡å®šå¾‹(ç·šåœˆå‹•)</title>
    <style>
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 800px;
            width: 100%;
        }
        canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        
        .controls-area {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .flow-toggle {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
        }
        input[type="radio"] { transform: scale(1.3); cursor: pointer; }

        .btn-group {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: bold;
            transition: 0.2s;
        }
        .btn-manual { background-color: #607D8B; color: white; }
        .btn-enter { background-color: #4CAF50; color: white; }
        .btn-inside { background-color: #FF9800; color: white; }
        .btn-exit { background-color: #f44336; color: white; }
        button:hover { opacity: 0.9; transform: scale(1.05); }
        button.active { box-shadow: 0 0 0 3px #333; }

        .slider-container { margin-top: 10px; }
        input[type=range] { width: 80%; cursor: pointer; }

        .status-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4fd;
            border-left: 5px solid #2196F3;
            text-align: left;
            line-height: 1.6;
            min-height: 140px;
        }
        .status-title { font-weight: bold; font-size: 1.2em; color: #1565C0; margin-bottom: 8px; }
        .highlight { color: #d32f2f; font-weight: bold; }
        .note { font-size: 0.9em; color: #666; font-style: italic;}
    </style>
</head>
<body>

    <div class="container">
        <h1>å†·æ¬¡å®šå¾‹(ç·šåœˆå‹•)</h1>
        
        <div class="legend" style="display:flex; justify-content:center; gap:20px; margin-bottom:10px; font-size:0.9em;">
            <div><span style="display:inline-block;width:10px;height:10px;background:gray;border-radius:50%;"></span> å¤–ç£å ´(å…¥)</div>
            <div><span style="display:inline-block;width:10px;height:10px;background:blue;"></span> é›»æµ(I)</div>
            <div><span style="display:inline-block;width:10px;height:10px;background:#e53935;"></span> é›»å­æµ(eâ»)</div>
        </div>

        <canvas id="simCanvas" width="700" height="360"></canvas>

        <div class="controls-area">
            <div class="flow-toggle">
                <label class="radio-label" style="color:#1565C0;">
                    <input type="radio" name="flowType" value="current" checked onchange="setFlowType('current')">
                    é¡¯ç¤ºé›»æµ (I)
                </label>
                <label class="radio-label" style="color:#e53935;">
                    <input type="radio" name="flowType" value="electron" onchange="setFlowType('electron')">
                    é¡¯ç¤ºé›»å­æµ (eâ»)
                </label>
            </div>

            <div class="btn-group">
                <button class="btn-manual active" onclick="setMode('manual')">ğŸ– æ‰‹å‹•æ“ä½œ</button>
                <button class="btn-enter" onclick="setMode('enter')">ğŸ“¸ å®šæ ¼ï¼šé€²å…¥</button>
                <button class="btn-inside" onclick="setMode('inside')">ğŸ“¸ å®šæ ¼ï¼šåœ¨å…§</button>
                <button class="btn-exit" onclick="setMode('exit')">ğŸ“¸ å®šæ ¼ï¼šé›¢é–‹</button>
            </div>

            <div class="slider-container">
                <input type="range" id="coilPos" min="0" max="600" value="50">
            </div>
        </div>

        <div class="status-panel" id="statusText">
            <div class="status-title">ç‹€æ…‹ï¼šç·šåœˆåœ¨ç£å ´å¤–</div>
            ç„¡æ„Ÿæ‡‰é›»æµã€‚
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('coilPos');
        const statusDiv = document.getElementById('statusText');

        const fieldStart = 250;
        const fieldWidth = 300;
        const fieldEnd = fieldStart + fieldWidth;
        const coilWidth = 120;
        const coilHeight = 120;
        const coilY = 115;

        let coilX = 50; 
        let lastCoilX = 50; 
        let offsetCounter = 0; // ç”¨æ–¼å‹•ç•«è·‘å‹•
        let currentMode = 'manual'; 
        let flowType = 'current'; 

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawMagneticField();

            let state = determineState();
            if (currentMode !== 'manual') {
                coilX = state.forcedX;
            }

            // ç¹ªè£½ç·šåœˆæ¡†æ¶
            drawCoilFrame(coilX);

            // ç¹ªè£½æµå‹•å‹•ç•«èˆ‡ç®­é ­
            if (state.currentDir !== "none") {
                // 1. æ±ºå®šè¦–è¦ºæ–¹å‘
                // ç‰©ç†ä¸Šï¼šé€²å…¥=CCW, é›¢é–‹=CW (é›»æµ I)
                let visualDir = state.currentDir; 
                if (flowType === 'electron') {
                    // é›»å­æµæ–¹å‘èˆ‡é›»æµç›¸å
                    visualDir = (state.currentDir === 'ccw') ? 'cw' : 'ccw';
                }
                
                drawFlowAnimation(visualDir, coilX, flowType);
                drawInducedField(state.currentDir, coilX); // æ„Ÿæ‡‰ç£å ´æ°¸é ç”±é›»æµæ±ºå®š
            }

            drawGalvanometer(state.currentDir, coilX);
            updateStatusText(state);

            if (currentMode === 'manual') lastCoilX = coilX;
            
            // å‹•ç•«è¨ˆæ•¸å™¨æŒçºŒå¢åŠ 
            offsetCounter += 1; 

            requestAnimationFrame(draw);
        }

        function determineState() {
            let speed = coilX - lastCoilX;
            let fluxChange = "none";
            let currentDir = "none"; 
            const coilLeft = coilX;
            const coilRight = coilX + coilWidth;

            // ç‰©ç†é‚è¼¯ï¼šåˆ¤æ–·ã€Œé›»æµ (I)ã€çš„æ–¹å‘
            // é€²å…¥ç£å ´(Nå…¥) -> æŠµæŠ—è®ŠåŒ– -> ç”¢ç”Ÿ(Nå‡º) -> é›»æµé€†æ™‚é‡ (CCW)
            // é›¢é–‹ç£å ´(Nå…¥) -> æŠµæŠ—è®ŠåŒ– -> ç”¢ç”Ÿ(Nå…¥) -> é›»æµé †æ™‚é‡ (CW)

            if (currentMode === 'manual') {
                if (speed > 0) { // å‘å³
                    if (coilRight > fieldStart && coilLeft < fieldStart) {
                        fluxChange = "increasing"; currentDir = "ccw";
                    } else if (coilLeft > fieldStart && coilRight < fieldEnd) {
                        fluxChange = "constant"; currentDir = "none";
                    } else if (coilRight > fieldEnd && coilLeft < fieldEnd) {
                        fluxChange = "decreasing"; currentDir = "cw";
                    }
                } else if (speed < 0) { // å‘å·¦
                    if (coilRight > fieldEnd && coilLeft < fieldEnd) {
                        fluxChange = "increasing"; currentDir = "ccw"; 
                    } else if (coilLeft > fieldStart && coilRight < fieldEnd) {
                        fluxChange = "constant"; currentDir = "none";
                    } else if (coilRight > fieldStart && coilLeft < fieldStart) {
                        fluxChange = "decreasing"; currentDir = "cw"; 
                    }
                }
                return { fluxChange, currentDir, speed, mode: 'manual' };
            } 
            else if (currentMode === 'enter') {
                return { fluxChange: "increasing", currentDir: "ccw", speed: 1, forcedX: fieldStart - coilWidth/2 + 20, mode: 'demo' };
            } else if (currentMode === 'inside') {
                return { fluxChange: "constant", currentDir: "none", speed: 0, forcedX: fieldStart + fieldWidth/2 - coilWidth/2, mode: 'demo' };
            } else if (currentMode === 'exit') {
                return { fluxChange: "decreasing", currentDir: "cw", speed: 1, forcedX: fieldEnd - coilWidth/2 - 20, mode: 'demo' };
            }
        }

        function drawMagneticField() {
            ctx.fillStyle = "#e0e0e0";
            ctx.fillRect(fieldStart, 50, fieldWidth, 250);
            
            ctx.fillStyle = "#d32f2f"; ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
            ctx.fillText("N (ä¸Šæ–¹)", fieldStart + fieldWidth/2, 40);
            ctx.fillStyle = "#1976D2";
            ctx.fillText("S (ä¸‹æ–¹)", fieldStart + fieldWidth/2, 320);

            ctx.fillStyle = "#999"; ctx.font = "16px Arial";
            for (let x = fieldStart + 20; x < fieldEnd; x += 40) {
                for (let y = 70; y < 300; y += 40) ctx.fillText("âœ•", x, y);
            }
        }

        function drawCoilFrame(xPos) {
            ctx.lineWidth = 6;
            ctx.strokeStyle = "#ff9800"; 
            ctx.strokeRect(xPos, coilY, coilWidth, coilHeight);
        }

        function drawFlowAnimation(dir, xPos, type) {
            let color = (type === 'current') ? "#2979ff" : "#e53935"; 
            let dashStyle = (type === 'current') ? [10, 10] : [5, 12];
            
            ctx.lineWidth = 4;
            ctx.strokeStyle = color;
            ctx.setLineDash(dashStyle);
            
            // é€™è£¡ä½¿ç”¨æ˜ç¢ºçš„è·¯å¾‘ç¹ªè£½ï¼Œç¢ºä¿ç¹è¡Œæ–¹å‘æ˜¯ã€Œé †æ™‚é‡ (Top-Left -> Top-Right -> ...)ã€
            // é€™æ¨£æˆ‘å€‘å°±å¯ä»¥ç²¾ç¢ºæ§åˆ¶ lineDashOffset ä¾†æ±ºå®šè¦–è¦ºæµå‹•æ–¹å‘
            
            ctx.beginPath();
            ctx.moveTo(xPos, coilY); // Top-Left
            ctx.lineTo(xPos + coilWidth, coilY); // Top-Right
            ctx.lineTo(xPos + coilWidth, coilY + coilHeight); // Bottom-Right
            ctx.lineTo(xPos, coilY + coilHeight); // Bottom-Left
            ctx.closePath(); // Back to Top-Left

            // æ§åˆ¶è™›ç·šæµå‹•
            // Canvas è·¯å¾‘å¾ä¸Šé¢ç•«æ˜¯ã€Œé †æ™‚é‡ã€ç¹çš„
            // è‹¥è¦çœ‹èµ·ä¾†æ˜¯é †æ™‚é‡(CW)æµå‹•ï¼šoffset æ‡‰è©²è¦ã€Œæ¸›å°‘ã€(å¾€å‰è·‘)
            // è‹¥è¦çœ‹èµ·ä¾†æ˜¯é€†æ™‚é‡(CCW)æµå‹•ï¼šoffset æ‡‰è©²è¦ã€Œå¢åŠ ã€(å¾€å¾Œé€€)
            
            if (dir === "cw") {
                ctx.lineDashOffset = -offsetCounter * 2; 
            } else {
                ctx.lineDashOffset = offsetCounter * 2;
            }

            ctx.stroke();
            ctx.setLineDash([]); // é‡ç½®

            // ç¹ªè£½ç®­é ­ (ä¿æŒçµ•å°æ­£ç¢º)
            ctx.fillStyle = color;
            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center"; 
            
            let sUp="â–²", sDown="â–¼", sLeft="â—€", sRight="â–¶";
            let labelOffset = (type === 'electron') ? 28 : 25;
            let eLabel = (type === 'electron') ? "eâ»" : "";
            
            if (dir === "ccw") {
                // è¦–è¦ºé€†æ™‚é‡ (Counter-Clockwise)
                // ä¸Šé‚Šï¼šå‘å·¦
                // å·¦é‚Šï¼šå‘ä¸‹
                // å³é‚Šï¼šå‘ä¸Š
                ctx.fillText(sLeft, xPos + coilWidth/2, coilY - 10); 
                ctx.fillText(sDown, xPos - 15, coilY + coilHeight/2); 
                ctx.fillText(sUp, xPos + coilWidth + 15, coilY + coilHeight/2); 
            } else {
                // è¦–è¦ºé †æ™‚é‡ (Clockwise)
                // ä¸Šé‚Šï¼šå‘å³
                // å·¦é‚Šï¼šå‘ä¸Š
                // å³é‚Šï¼šå‘ä¸‹
                ctx.fillText(sRight, xPos + coilWidth/2, coilY - 10); 
                ctx.fillText(sUp, xPos - 15, coilY + coilHeight/2); 
                ctx.fillText(sDown, xPos + coilWidth + 15, coilY + coilHeight/2); 
            }

            if(type === 'electron') ctx.fillText(eLabel, xPos + coilWidth/2, coilY - labelOffset);
        }

        function drawInducedField(dir, xPos) {
            const cx = xPos + coilWidth / 2;
            const cy = coilY + coilHeight / 2;
            ctx.fillStyle = "blue";
            ctx.textAlign = "center";

            if (dir === "ccw") { 
                // é›»æµé€†æ™‚é‡ -> B' å‘ä¸Š
                ctx.font = "bold 16px Arial";
                ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillText("B' (å‘ä¸Š)", cx, cy - 25);
            } else { 
                // é›»æµé †æ™‚é‡ -> B' å‘ä¸‹
                ctx.font = "bold 24px Arial";
                ctx.fillText("âœ•", cx, cy + 8);
                ctx.font = "bold 16px Arial";
                ctx.fillText("B' (å‘ä¸‹)", cx, cy - 25);
            }
        }

        function drawGalvanometer(dir, xPos) {
            const gx = xPos + coilWidth / 2;
            const gy = coilY + coilHeight + 10;
            const r = 18; 

            ctx.beginPath(); 
            ctx.arc(gx, gy, r, 0, Math.PI * 2);
            ctx.fillStyle = "white"; 
            ctx.fill();
            ctx.strokeStyle = "#333"; 
            ctx.lineWidth = 3; 
            ctx.stroke();

            ctx.beginPath(); 
            ctx.moveTo(gx, gy + 5);
            let angle = 0;
            // æŒ‡é‡æ°¸é è·Ÿéš¨ã€Œé›»æµ Iã€
            if (dir === "ccw") angle = -Math.PI / 4; 
            if (dir === "cw") angle = Math.PI / 4;   
            
            ctx.lineTo(gx + Math.sin(angle)*14, gy - Math.cos(angle)*14);
            ctx.strokeStyle = "red"; 
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = "black"; 
            ctx.font = "bold 12px Arial"; 
            ctx.textAlign = "center";
            ctx.fillText("G", gx, gy + 32);
        }

        function updateStatusText(state) {
            let title = "";
            let desc = "";
            let badge = state.mode === 'demo' ? '(å®šæ ¼)' : '';
            
            let flowText = "";
            if (state.currentDir !== 'none') {
                if (flowType === 'current') {
                    let dirName = state.currentDir === 'ccw' ? 'é€†æ™‚é‡ (CCW)' : 'é †æ™‚é‡ (CW)';
                    flowText = `3. æ„Ÿæ‡‰é›»æµ(I)ï¼š<span class="highlight" style="color:#2979ff">${dirName}</span>`;
                } else {
                    let eDir = state.currentDir === 'ccw' ? 'é †æ™‚é‡ (CW)' : 'é€†æ™‚é‡ (CCW)';
                    flowText = `3. é›»å­æµ(eâ»)ï¼š<span class="highlight" style="color:#e53935">${eDir}</span> <span class="note">(èˆ‡é›»æµæ–¹å‘ç›¸å)</span>`;
                }
            } else {
                flowText = "3. ç„¡é›»æµ/é›»å­æµ";
            }

            if (state.fluxChange === "increasing") {
                title = `ç‹€æ…‹ï¼šé€²å…¥ç£å ´ä¸­ (Entering) ${badge}`;
                desc = `
                    1. å‘ä¸‹çš„ç£åŠ›ç·šæ•¸ç›® <span class="highlight">è®Šå¤š (â†‘)</span>ã€‚<br>
                    2. ç·šåœˆæŠµæŠ—è®ŠåŒ–ï¼Œç”¢ç”Ÿ <span class="highlight">å‘ä¸Š (â—)</span> çš„æ„Ÿæ‡‰ç£å ´ã€‚<br>
                    ${flowText}
                `;
            } else if (state.fluxChange === "constant") {
                title = `ç‹€æ…‹ï¼šå®Œå…¨åœ¨ç£å ´å…§ / ç„¡è®ŠåŒ–`;
                desc = `ç„¡ç£é€šé‡è®ŠåŒ–ï¼Œç„¡æ„Ÿæ‡‰é›»æµã€‚`;
            } else if (state.fluxChange === "decreasing") {
                title = `ç‹€æ…‹ï¼šé›¢é–‹ç£å ´ä¸­ (Exiting) ${badge}`;
                desc = `
                    1. å‘ä¸‹çš„ç£åŠ›ç·šæ•¸ç›® <span class="highlight">è®Šå°‘ (â†“)</span>ã€‚<br>
                    2. ç·šåœˆæŠµæŠ—è®ŠåŒ–ï¼Œç”¢ç”Ÿ <span class="highlight">å‘ä¸‹ (âœ•)</span> çš„æ„Ÿæ‡‰ç£å ´ã€‚<br>
                    ${flowText}
                `;
            } else {
                title = "ç‹€æ…‹ï¼šç£å ´å¤–";
                desc = "ç„¡ç£å ´å½±éŸ¿ã€‚";
            }

            statusDiv.innerHTML = `<div class="status-title">${title}</div>${desc}`;
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.btn-group button').forEach(btn => btn.classList.remove('active'));
            if(mode === 'manual') document.querySelector('.btn-manual').classList.add('active');
            if(mode === 'enter') document.querySelector('.btn-enter').classList.add('active');
            if(mode === 'inside') document.querySelector('.btn-inside').classList.add('active');
            if(mode === 'exit') document.querySelector('.btn-exit').classList.add('active');

            if (mode === 'manual') {
                slider.disabled = false;
                coilX = 50; slider.value = 50;
            } else {
                slider.disabled = true;
            }
        }

        function setFlowType(type) {
            flowType = type;
        }

        slider.addEventListener('input', (e) => {
            if(currentMode === 'manual') coilX = parseInt(e.target.value);
        });

        requestAnimationFrame(draw);

    </script>
</body>
</html>