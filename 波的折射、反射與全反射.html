<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ³¢çš„æŠ˜å°„</title>
    <style>
        :root {
            --primary-color: #3498db;
            --success-color: #28a745;
            --bg-color: #f4f6f8;
            --panel-bg: #ffffff;
            --text-main: #2c3e50;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: var(--text-main);
            margin: 0;
        }

        h1 {
            color: var(--text-main);
            margin: 10px 0;
            font-size: 1.6em;
            font-weight: 700;
        }

        .container {
            background: var(--panel-bg);
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 950px; 
            width: 100%;
            box-sizing: border-box;
        }

        /* --- æ¥µç°¡æ§åˆ¶å€å¡Š --- */
        .controls-compact {
            width: 100%;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .row-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        button {
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .btn-mode {
            background-color: #e2e6ea;
            color: #555;
        }

        .btn-mode.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 2px 4px rgba(52, 152, 219, 0.3);
        }

        .btn-action {
            background-color: var(--success-color);
            color: white;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        }
        .btn-action:hover { background-color: #218838; }
        .btn-action:active { transform: translateY(1px); }

        /* --- ä¸‰æ¬„ä½ˆå±€ --- */
        .row-sliders {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 20px;
            align-items: stretch; 
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 8px; 
            background: #fff;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #eee;
            box-sizing: border-box;
            justify-content: center;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            font-weight: 600;
            color: #555;
            flex-wrap: wrap; 
            gap: 5px;
        }

        .slider-header span.val {
            font-family: monospace;
            color: var(--primary-color);
            background: #eef5fb;
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* ä¸‹æ‹‰é¸å–® */
        .preset-select {
            font-size: 0.8em;
            padding: 2px 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            color: #555;
            background: #fff;
            cursor: pointer;
            width: 100%; 
            margin-top: 2px;
        }
        .preset-select option[disabled][selected] { display: none; }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            height: 6px;
            background: #dee2e6;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            margin-top: 5px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); }

        .row-checkbox {
            display: flex;
            justify-content: center;
            border-top: 1px solid #e9ecef;
            padding-top: 10px;
            margin-top: 0;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.9em;
            color: #555;
            user-select: none;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
            cursor: pointer;
        }

        canvas {
            background-color: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.02);
            width: 100%;
            height: auto;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.85em;
            flex-wrap: wrap;
            justify-content: center;
            color: #666;
        }

        .legend-item { display: flex; align-items: center; gap: 6px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .line { width: 20px; height: 3px; display: inline-block; }
        .c-blue { background: #3498db; }
        .c-green { background: #2ecc71; }
        .c-orange { background: #e67e22; }
        .c-grey { background: transparent; border: 2px solid #bdc3c7; box-sizing: border-box; }
        .c-red-dash { border-bottom: 2px dashed #e74c3c; width: 20px; height: 0; display: inline-block;}

        .learning-guide {
            width: 100%;
            background-color: #fffbf2;
            border-left: 4px solid #f1c40f;
            padding: 15px 20px;
            border-radius: 0 6px 6px 0;
            margin-top: 5px;
            font-size: 0.95em;
        }

        .learning-guide h3 {
            margin: 0 0 10px 0;
            color: #d35400;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .guide-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .guide-box h4 { margin: 0 0 5px 0; color: #2c3e50; font-size: 1em; }
        .guide-box ul { margin: 0; padding-left: 18px; color: #555; line-height: 1.5; }

        @media (max-width: 768px) {
            .row-sliders { grid-template-columns: 1fr; gap: 15px; }
            .guide-content { grid-template-columns: 1fr; gap: 15px; }
            .controls-compact { padding: 15px; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>æ³¢çš„æŠ˜å°„ã€åå°„èˆ‡å…¨åå°„</h1>

        <div class="controls-compact">
            <div class="row-buttons">
                <button id="btnReflect" class="btn-mode active" onclick="setMode('reflection')">æ¨¡å¼ A: åå°„</button>
                <button id="btnRefract" class="btn-mode" onclick="setMode('refraction')">æ¨¡å¼ B: æŠ˜å°„</button>
                <button id="btnEmit" class="btn-action" onclick="emitNewWave()">ç™¼å°„æ–°æ³¢</button>
            </div>

            <div class="row-sliders">
                <div class="slider-group">
                    <div class="slider-header">
                        <label>å…¥å°„è§’åº¦ (Î¸â‚)</label>
                        <span id="angleValue" class="val">45Â°</span>
                    </div>
                    <input type="range" id="angleSlider" min="10" max="80" value="45">
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <label>ä¸Šæ–¹ä»‹è³ª nâ‚</label>
                        <span id="n1Value" class="val">1.0</span>
                    </div>
                    <select id="n1Preset" class="preset-select" onchange="applyPreset('n1', this.value)">
                        <option value="" disabled selected>é¸æ“‡æè³ª...</option>
                        <option value="1.0">ç©ºæ°£/çœŸç©º (1.0)</option>
                        <option value="1.33">æ°´ (1.33)</option>
                        <option value="1.5">ç»ç’ƒ (1.5)</option>
                        <option value="2.4">é‘½çŸ³ (2.4)</option>
                    </select>
                    <input type="range" id="n1Slider" min="1.0" max="2.5" step="0.01" value="1.0">
                </div>

                <div class="slider-group" id="n2-group">
                    <div class="slider-header">
                        <label>ä¸‹æ–¹ä»‹è³ª nâ‚‚</label>
                        <span id="n2Value" class="val">1.5</span>
                    </div>
                    <select id="n2Preset" class="preset-select" onchange="applyPreset('n2', this.value)">
                        <option value="" disabled selected>é¸æ“‡æè³ª...</option>
                        <option value="1.0">ç©ºæ°£/çœŸç©º (1.0)</option>
                        <option value="1.33">æ°´ (1.33)</option>
                        <option value="1.5">ç»ç’ƒ (1.5)</option>
                        <option value="2.4">é‘½çŸ³ (2.4)</option>
                    </select>
                    <input type="range" id="n2Slider" min="1.0" max="2.5" step="0.01" value="1.5">
                </div>
            </div>

            <div class="row-checkbox">
                <label class="checkbox-label">
                    <input type="checkbox" id="chkHuygens" onchange="toggleHuygens()">
                    <span>é¡¯ç¤ºæƒ æ›´æ–¯åŸç†ç´°ç¯€ (é»æ³¢æºèˆ‡å­æ³¢)</span>
                </label>
            </div>
        </div>
        
        <canvas id="simCanvas" width="800" height="400"></canvas>

        <div class="legend">
            <div class="legend-item"><span class="line c-blue"></span> å…¥å°„æ³¢</div>
            <div class="legend-item"><span class="line c-green"></span> çµæœæ³¢å‰</div>
            <div class="legend-item"><span class="c-red-dash"></span> å…‰ç·šç¤ºæ„</div>
            <div class="legend-item" id="legendSource" style="opacity: 0.3;"><span class="dot c-orange"></span> é»æ³¢æº</div>
            <div class="legend-item" id="legendWavelet" style="opacity: 0.3;"><span class="dot c-grey"></span> å­æ³¢</div>
        </div>

        <div class="learning-guide">
            <h3>ğŸ’¡ å­¸ç¿’å¼•å°</h3>
            <div class="guide-content">
                <div class="guide-box">
                    <h4>è§€å¯Ÿåå°„ (Reflection)</h4>
                    <ul>
                        <li><strong>è§€å¯Ÿé‡é»ï¼š</strong>è—è‰²å…¥å°„æ³¢æ¥è§¸ä»‹é¢æ™‚ï¼Œæ©˜è‰²é»ç”¢ç”Ÿå­æ³¢ï¼Œå­æ³¢çš„åˆ‡ç·šå½¢æˆåå°„æ³¢å‰ã€‚</li>
                        <li><strong>çµè«–ï¼š</strong>åå°„è§’ Î¸â‚‚ ç­‰æ–¼å…¥å°„è§’ Î¸â‚ã€‚</li>
                    </ul>
                </div>
                <div class="guide-box">
                    <h4>è§€å¯ŸæŠ˜å°„ (Refraction)</h4>
                    <ul>
                        <li><strong>å…‰å¾å¿«å…¥æ…¢ (nâ‚ &lt; nâ‚‚)ï¼š</strong>å…‰ç·šåå‘æ³•ç·šã€‚</li>
                        <li><strong>å…‰å¾æ…¢å…¥å¿« (nâ‚ &gt; nâ‚‚)ï¼š</strong>å…‰ç·šåé›¢æ³•ç·šã€‚</li>
                        <li><strong>âš ï¸ å…¨åå°„ï¼š</strong>è‹¥ nâ‚ &gt; nâ‚‚ ä¸”å…¥å°„è§’è¶…éè‡¨ç•Œè§’ï¼Œå…‰ç·šç„¡æ³•æŠ˜å°„é€²å…¥ç¬¬äºŒä»‹è³ªï¼Œå…¨éƒ¨åå°„å›ç¬¬ä¸€ä»‹è³ªã€‚</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- åƒæ•¸è¨­å®š ---
        let mode = 'reflection'; 
        let angleDeg = 45;      
        let n1 = 1.0;           
        let n2 = 1.5;           
        const c_speed = 1.2;    
        const SOURCE_COUNT = 30; 
        const INTERFACE_Y = canvas.height / 2;
        
        let showHuygensDetails = false;

        // --- ç‰©ä»¶é›†åˆ ---
        let incidentWaves = []; 
        let sources = [];               
        let wavelets = [];              
        let frameCount = 0; 
        let waveIdCounter = 0; 

        function initSources() {
            sources = [];
            const startX = 50;
            const endX = 750;
            const gap = (endX - startX) / (SOURCE_COUNT - 1);

            for (let i = 0; i < SOURCE_COUNT; i++) {
                sources.push({
                    index: i,
                    x: startX + i * gap,
                    y: INTERFACE_Y
                });
            }
        }

        class IncidentWave {
            constructor(id) {
                this.id = id;
                this.spawnTime = frameCount; 
                this.active = true;
                const thetaRad = (angleDeg * Math.PI) / 180;
                
                // å…¥å°„æ³¢é€Ÿåº¦ v1
                this.v1 = c_speed / n1; 
                
                this.vx = Math.sin(thetaRad) * this.v1;
                this.vy = Math.cos(thetaRad) * this.v1;

                this.centerX = sources[0].x - 120; 
                this.centerY = INTERFACE_Y - 120 / Math.cos(thetaRad); 
                
                this.triggeredSources = new Set();
            }

            update() {
                this.centerX += this.vx;
                this.centerY += this.vy;

                if (this.centerY > canvas.height + 300 && this.centerX > canvas.width + 300) {
                    this.active = false;
                    return;
                }
                
                this.checkSourceTrigger();
            }

            checkSourceTrigger() {
                const thetaRad = (angleDeg * Math.PI) / 180;
                const normalX = Math.sin(thetaRad);
                const normalY = Math.cos(thetaRad);
                const currentWavefrontPos = normalX * this.centerX + normalY * this.centerY;

                sources.forEach(src => {
                    if (this.triggeredSources.has(src.index)) return;
                    const sourceProjPos = normalX * src.x + normalY * src.y;
                    
                    if (currentWavefrontPos >= sourceProjPos - 0.5) {
                        triggerWavelet(src, this.id);
                        this.triggeredSources.add(src.index);
                    }
                });
            }

            draw() {
                const thetaRad = (angleDeg * Math.PI) / 180;
                const dirX = Math.cos(thetaRad);
                const dirY = -Math.sin(thetaRad); 
                const length = 1000; 

                ctx.beginPath();
                ctx.moveTo(this.centerX - dirX * length, this.centerY - dirY * length);
                ctx.lineTo(this.centerX + dirX * length, this.centerY + dirY * length);
                
                ctx.save();
                ctx.rect(0, 0, canvas.width, INTERFACE_Y); 
                ctx.clip();
                
                ctx.strokeStyle = '#3498db'; 
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.restore();
            }
        }

        function triggerWavelet(source, waveId) {
            let actualMode = mode;
            let speedN = n2; // é è¨­ç”¨ n2 æ±ºå®šé€Ÿåº¦

            if (mode === 'refraction') {
                const sinIn = Math.sin((angleDeg * Math.PI) / 180);
                const sinOut = (n1 * sinIn) / n2;
                
                // å…¨åå°„åˆ¤æ–·
                if (Math.abs(sinOut) > 1.0) {
                    actualMode = 'reflection'; // å¼·åˆ¶è½‰ç‚ºåå°„æ¨¡å¼
                    speedN = n1; // é€Ÿåº¦å›åˆ° n1
                }
            } else {
                speedN = n1; // åå°„æ¨¡å¼ä¸‹é€Ÿåº¦ç”± n1 æ±ºå®š
            }

            wavelets.push({
                x: source.x,
                y: source.y,
                spawnTime: frameCount, 
                mode: actualMode, // ç´€éŒ„å¯¦éš›ç™¼ç”Ÿçš„æ³¢æ¨¡å¼ (reflection or refraction)
                waveId: waveId,
                n1_at_spawn: n1, 
                n2_at_spawn: n2,
                speedN: speedN // ç´€éŒ„è¨ˆç®—é€Ÿåº¦ç”¨çš„æŠ˜å°„ç‡
            });
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawInterfaceAndLabels();

            const waveletsByWaveId = {};

            for (let i = wavelets.length - 1; i >= 0; i--) {
                let w = wavelets[i];
                // è¨ˆç®—é€Ÿåº¦
                let v_expansion = c_speed / w.speedN;
                w.r = v_expansion * (frameCount - w.spawnTime);

                if (w.r > 1000) { 
                    wavelets.splice(i, 1);
                    continue;
                }

                if (showHuygensDetails) {
                    ctx.beginPath();
                    if (w.mode === 'reflection') {
                        ctx.arc(w.x, w.y, w.r, Math.PI, 0); 
                    } else {
                        ctx.arc(w.x, w.y, w.r, 0, Math.PI); 
                    }
                    ctx.strokeStyle = 'rgba(127, 140, 141, 0.4)'; 
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                if (!waveletsByWaveId[w.waveId]) {
                    waveletsByWaveId[w.waveId] = [];
                }
                waveletsByWaveId[w.waveId].push(w);
            }

            Object.values(waveletsByWaveId).forEach(group => {
                drawEnvelopeForGroup(group);
            });

            for (let i = incidentWaves.length - 1; i >= 0; i--) {
                let wave = incidentWaves[i];
                wave.update();
                if (!wave.active) {
                    incidentWaves.splice(i, 1);
                } else {
                    wave.draw();
                }
            }

            if (showHuygensDetails) {
                sources.forEach(src => {
                    ctx.beginPath();
                    ctx.arc(src.x, src.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#e67e22';
                    ctx.fill();
                });
            }
            
            frameCount++;
            requestAnimationFrame(update);
        }

        function drawEnvelopeForGroup(group) {
            if (group.length < 2) return;

            const minRadius = 0.1;
            const relevantWavelets = group.filter(w => w.r > minRadius);
            
            if (relevantWavelets.length < 2) return;

            relevantWavelets.sort((a, b) => a.x - b.x);
            let firstW = relevantWavelets[0];
            let lastW = relevantWavelets[relevantWavelets.length - 1];

            let envelopeAngle; 
            
            // æ³¨æ„ï¼šé€™è£¡ä½¿ç”¨ firstW.mode ä¾†åˆ¤æ–·ï¼Œå› ç‚ºå…¨åå°„æ™‚ mode æœƒè®Šæˆ 'reflection'
            if (firstW.mode === 'reflection') {
                const thetaInRad = (angleDeg * Math.PI) / 180;
                envelopeAngle = Math.PI/2 + thetaInRad; 
            } else {
                const thetaInRad = (angleDeg * Math.PI) / 180;
                const gn1 = firstW.n1_at_spawn;
                const gn2 = firstW.n2_at_spawn;
                let sinOut = (gn1 * Math.sin(thetaInRad)) / gn2;
                
                if (Math.abs(sinOut) > 1.0) return; // ç†è«–ä¸Šä¸è©²é€²åˆ°é€™è£¡ï¼Œå› ç‚º mode å·²ç¶“è½‰äº†
                
                const thetaOutRad = Math.asin(sinOut);
                envelopeAngle = Math.PI/2 - thetaOutRad; 
            }

            let p1x, p1y, p2x, p2y; 
            const extend = 30; 

            if (firstW.mode === 'reflection') {
                p1x = firstW.x - firstW.r * Math.cos(envelopeAngle);
                p1y = firstW.y - firstW.r * Math.sin(envelopeAngle);
                p2x = lastW.x - lastW.r * Math.cos(envelopeAngle);
                p2y = lastW.y - lastW.r * Math.sin(envelopeAngle);
            } else {
                p1x = firstW.x + firstW.r * Math.cos(envelopeAngle);
                p1y = firstW.y + firstW.r * Math.sin(envelopeAngle);
                p2x = lastW.x + lastW.r * Math.cos(envelopeAngle);
                p2y = lastW.y + lastW.r * Math.sin(envelopeAngle);
            }

            ctx.save();
            ctx.beginPath();
            
            const lineLen = Math.sqrt((p2x-p1x)**2 + (p2y-p1y)**2);
            if (lineLen > 0) {
                const dx = (p2x - p1x) / lineLen;
                const dy = (p2y - p1y) / lineLen;
                ctx.moveTo(p1x - dx * extend, p1y - dy * extend);
                ctx.lineTo(p2x + dx * extend, p2y + dy * extend);
            } else {
                ctx.moveTo(p1x, p1y);
                ctx.lineTo(p2x, p2y);
            }

            if (firstW.mode === 'reflection') {
                ctx.rect(0, 0, canvas.width, INTERFACE_Y);
            } else {
                ctx.rect(0, INTERFACE_Y, canvas.width, canvas.height - INTERFACE_Y);
            }
            ctx.clip();
            
            ctx.strokeStyle = '#2ecc71'; 
            ctx.lineWidth = 4;
            ctx.lineCap = 'round'; 
            ctx.stroke();
            ctx.restore();
        }

        function drawInterfaceAndLabels() {
            ctx.beginPath();
            ctx.moveTo(0, INTERFACE_Y);
            ctx.lineTo(canvas.width, INTERFACE_Y);
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.font = "16px Arial";
            ctx.fillStyle = "#7f8c8d";
            ctx.fillText(`ä»‹è³ª 1 (nâ‚=${n1.toFixed(2)})`, 20, INTERFACE_Y - 20);
            ctx.fillText(`ä»‹è³ª 2 (nâ‚‚=${n2.toFixed(2)})`, 20, INTERFACE_Y + 35);

            const normalX = canvas.width / 2;
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(normalX, INTERFACE_Y - 140);
            ctx.lineTo(normalX, INTERFACE_Y + 140);
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);

            drawAngleIndicators(normalX, INTERFACE_Y);

            if (mode === 'refraction') {
                ctx.save();
                ctx.font = "bold 16px 'Segoe UI', sans-serif";
                ctx.fillStyle = "#2c3e50";
                ctx.textAlign = "right";
                ctx.fillText("å¸ä¹ƒçˆ¾å®šå¾‹ (Snell's Law):", canvas.width - 20, 30);
                
                ctx.font = "italic 18px 'Times New Roman', serif";
                ctx.fillStyle = "#2c3e50";
                ctx.fillText("nâ‚ sin Î¸â‚ = nâ‚‚ sin Î¸â‚‚", canvas.width - 20, 55);
                ctx.restore();
            }
        }

        function drawAngleIndicators(normalX, normalY) {
            const angleInRad = (angleDeg * Math.PI) / 180;
            const rayLength = 120;
            let angleOutRad;
            let isTIR = false; 
            let isGrazing = false; 

            if (mode === 'refraction') {
                let sinIn = Math.sin(angleInRad);
                let sinOut = (n1 * sinIn) / n2;
                if (Math.abs(sinOut) > 1.0) { 
                    isTIR = true;
                    angleOutRad = Math.PI / 2; 
                } else {
                    angleOutRad = Math.asin(sinOut);
                    // åˆ¤æ–·æ˜¯å¦æ¥è¿‘è‡¨ç•Œè§’ (Grazing Angle)
                    if (Math.abs(sinOut - 1.0) < 0.01) isGrazing = true;
                }
            } else { 
                angleOutRad = angleInRad; 
            }
            
            ctx.save();
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([8, 6]);

            // å…¥å°„å…‰ç·š
            let inRayX = normalX - rayLength * Math.sin(angleInRad);
            let inRayY = normalY - rayLength * Math.cos(angleInRad);
            ctx.beginPath();
            ctx.moveTo(inRayX, inRayY);
            ctx.lineTo(normalX, normalY);
            ctx.stroke();
            drawArrow(ctx, inRayX, inRayY, normalX, normalY, 0.6);

            // åå°„å…‰ç·š (å…¨åå°„æˆ–åå°„æ¨¡å¼æ™‚é¡¯ç¤º)
            if (mode === 'reflection' || isTIR) {
                let reflectAngle = angleInRad;
                let reflectRayX = normalX + rayLength * Math.sin(reflectAngle);
                let reflectRayY = normalY - rayLength * Math.cos(reflectAngle);
                ctx.beginPath();
                ctx.moveTo(normalX, normalY);
                ctx.lineTo(reflectRayX, reflectRayY);
                ctx.stroke();
                drawArrow(ctx, normalX, normalY, reflectRayX, reflectRayY, 0.6);
            }

            // æŠ˜å°„å…‰ç·š (æ­£å¸¸æŠ˜å°„æˆ–è‡¨ç•Œè§’æ™‚é¡¯ç¤º)
            if (mode === 'refraction' && !isTIR) {
                let outRayX, outRayY;
                if (isGrazing) {
                    // æ å°„è§’ï¼šæ²¿è‘—ä»‹é¢å°„å‡º (90åº¦)
                    outRayX = normalX + rayLength;
                    outRayY = normalY;
                } else {
                    outRayX = normalX + rayLength * Math.sin(angleOutRad);
                    outRayY = normalY + rayLength * Math.cos(angleOutRad);
                }
                ctx.beginPath();
                ctx.moveTo(normalX, normalY);
                ctx.lineTo(outRayX, outRayY);
                ctx.stroke();
                drawArrow(ctx, normalX, normalY, outRayX, outRayY, 0.6);
            }
            
            ctx.restore();

            const arcRadius = 45;
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = '#333';
            ctx.fillStyle = '#c0392b';
            ctx.font = "bold 14px 'Segoe UI', Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // å…¥å°„è§’ Î¸â‚
            ctx.beginPath();
            ctx.arc(normalX, normalY, arcRadius, -Math.PI/2, -Math.PI/2 - angleInRad, true);
            ctx.stroke();
            
            let textAngle1 = -Math.PI/2 - angleInRad / 2;
            let textR = arcRadius + 25;
            ctx.fillText('å…¥å°„è§’ Î¸â‚', normalX + textR * Math.cos(textAngle1), normalY + textR * Math.sin(textAngle1));

            // åå°„è§’
            if (mode === 'reflection' || isTIR) {
                // å¦‚æœæ˜¯å…¨åå°„ï¼Œæˆ‘å€‘ä¹Ÿæ¨™ç¤ºåå°„è§’ï¼Œå› ç‚ºæ­¤æ™‚åå°„æ³¢æ˜¯ä¸»è§’
                ctx.beginPath();
                ctx.arc(normalX, normalY, arcRadius, -Math.PI/2, -Math.PI/2 + angleInRad);
                ctx.stroke();

                let textAngle2 = -Math.PI/2 + angleInRad / 2;
                ctx.fillText('åå°„è§’ Î¸â‚‚', normalX + textR * Math.cos(textAngle2) + 5, normalY + textR * Math.sin(textAngle2) + 10);
            }

            // æŠ˜å°„è§’èˆ‡å…¨åå°„æç¤º
            if (mode === 'refraction') {
                if (isTIR) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = "bold 16px 'Segoe UI', sans-serif";
                    ctx.textAlign = "left";
                    ctx.fillText('âš ï¸ ç™¼ç”Ÿå…¨åå°„', normalX + 60, normalY + 40);
                } else {
                    ctx.beginPath();
                    ctx.arc(normalX, normalY, arcRadius, Math.PI/2, Math.PI/2 - angleOutRad, true);
                    ctx.stroke();

                    let textAngle3 = Math.PI/2 - angleOutRad / 2;
                    let label = 'æŠ˜å°„è§’ Î¸â‚‚';
                    if (isGrazing) label = 'è‡¨ç•Œè§’ Î¸â‚‚â‰ˆ90Â°';

                    if (angleOutRad < Math.PI / 10) { 
                        ctx.fillText(label, normalX + textR * Math.cos(textAngle3) + 15, normalY + textR * Math.sin(textAngle3) + 10);
                    } else {
                         ctx.fillText(label, normalX + textR * Math.cos(textAngle3), normalY + textR * Math.sin(textAngle3) + 10);
                    }
                }
            }
        }
        
        function drawArrow(ctx, fromX, fromY, toX, toY, position) {
            const headlen = 8;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            const midX = fromX + dx * position;
            const midY = fromY + dy * position;

            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - headlen * Math.cos(angle - Math.PI / 6), midY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - headlen * Math.cos(angle + Math.PI / 6), midY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        const angleSlider = document.getElementById('angleSlider');
        const angleValue = document.getElementById('angleValue');
        const n1Slider = document.getElementById('n1Slider');
        const n2Slider = document.getElementById('n2Slider');
        const n1Value = document.getElementById('n1Value');
        const n2Value = document.getElementById('n2Value');
        
        angleSlider.addEventListener('input', (e) => {
            angleDeg = parseFloat(e.target.value);
            angleValue.textContent = angleDeg + "Â°";
            resetSimulation();
        });

        n1Slider.addEventListener('input', (e) => {
            n1 = parseFloat(e.target.value);
            n1Value.textContent = n1.toFixed(2);
            document.getElementById('n1Preset').value = ""; 
            resetSimulation();
        });

        n2Slider.addEventListener('input', (e) => {
            n2 = parseFloat(e.target.value);
            n2Value.textContent = n2.toFixed(2);
            document.getElementById('n2Preset').value = "";
            resetSimulation();
        });

        function applyPreset(target, val) {
            if (!val) return;
            val = parseFloat(val);
            if (target === 'n1') {
                n1 = val;
                n1Slider.value = val;
                n1Value.textContent = val.toFixed(2);
            } else {
                n2 = val;
                n2Slider.value = val;
                n2Value.textContent = val.toFixed(2);
            }
            resetSimulation();
        }
        
        function toggleHuygens() {
            showHuygensDetails = document.getElementById('chkHuygens').checked;
            
            document.getElementById('legendSource').style.opacity = showHuygensDetails ? '1' : '0.3';
            document.getElementById('legendWavelet').style.opacity = showHuygensDetails ? '1' : '0.3';
            document.getElementById('legendSource').innerHTML = showHuygensDetails ? 
                '<span class="dot c-orange"></span> é»æ³¢æº' : '<span class="dot c-orange"></span> é»æ³¢æº(éš±è—ä¸­)';
            document.getElementById('legendWavelet').innerHTML = showHuygensDetails ? 
                '<span class="dot c-grey"></span> å­æ³¢(åœ“å½¢)' : '<span class="dot c-grey"></span> å­æ³¢(éš±è—ä¸­)';
        }

        function setMode(newMode) {
            mode = newMode;
            document.getElementById('btnReflect').className = mode === 'reflection' ? 'btn-mode active' : 'btn-mode';
            document.getElementById('btnRefract').className = mode === 'refraction' ? 'btn-mode active' : 'btn-mode';
            
            const n2Group = document.getElementById('n2-group');
            if (mode === 'reflection') {
                n2Group.style.opacity = '0.5';
            } else {
                n2Group.style.opacity = '1';
            }
            resetSimulation();
        }

        function emitNewWave() {
            incidentWaves.push(new IncidentWave(waveIdCounter++));
        }

        function resetSimulation() {
            wavelets = [];
            incidentWaves = [];
            sources.forEach(s => {});
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawInterfaceAndLabels();
        }

        initSources();
        setMode('reflection'); 
        drawInterfaceAndLabels(); 
        requestAnimationFrame(update); 

    </script>
</body>
</html>