<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>等速圓周運動-常見例子</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #eef1f3; color: #333; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* --- 左側控制面板 --- */
        #ui-panel {
            position: absolute; top: 15px; left: 15px; width: 380px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border: 1px solid #ddd; max-height: 95vh; display: flex; flex-direction: column;
            z-index: 10;
        }

        .panel-header {
            padding: 12px 20px; background: #e3f2fd; border-bottom: 1px solid #bbdefb;
            display: flex; justify-content: space-between; align-items: center; border-radius: 12px 12px 0 0;
        }
        h2 { margin: 0; font-size: 1.2em; color: #1565c0; }
        #btn-toggle-panel { background: white; border: 1px solid #90caf9; cursor: pointer; padding: 2px 8px; border-radius: 4px; color: #1565c0;}

        .panel-content { padding: 15px 20px; overflow-y: auto; flex-grow: 1; }
        .hidden { display: none; } 

        #top-controls { display: flex; margin-bottom: 15px; gap: 10px; }
        
        /* --- 右側物理分析面板 --- */
        #eqn-panel {
            position: absolute; top: 15px; right: 15px; width: 340px;
            background: rgba(255, 255, 255, 0.96); padding: 0;
            border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border: 1px solid #ddd; overflow: hidden;
            z-index: 10;
            display: flex; flex-direction: column;
        }
        .eqn-title { 
            background: #1565c0; color: white; padding: 10px 15px; font-weight: bold; 
            font-size: 1.1em; display: flex; justify-content: space-between; flex-shrink: 0;
        }
        #vector-canvas { background: #fff; display: block; margin: 0 auto; border-bottom: 1px solid #eee; flex-shrink: 0; }
        #eqn-content { padding: 15px; overflow-y: auto; flex-grow: 1; }

        /* --- 數學符號樣式 --- */
        .math-row { 
            margin-bottom: 15px; font-family: 'Times New Roman', serif; font-size: 1.3em; 
            display: flex; align-items: center; flex-wrap: wrap;
        }
        .math-var { font-style: italic; }
        .math-sub { font-size: 0.7em; vertical-align: sub; margin-left: 1px; font-style: normal; }
        
        /* 分數結構 */
        .fraction { 
            display: inline-flex; flex-direction: column; align-items: center; 
            margin: 0 8px; vertical-align: middle;
        }
        .numerator { 
            border-bottom: 1px solid #000; padding-bottom: 2px; 
            display: block; text-align: center; width: 100%;
        }
        .denominator { 
            padding-top: 2px; display: block; text-align: center; width: 100%;
        }
        .note { font-family: 'Segoe UI', sans-serif; font-size: 0.8em; color: #666; width: 100%; margin-top: 8px; border-left: 3px solid #ccc; padding-left: 8px; line-height: 1.4;}

        /* --- UI 元件 --- */
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.9em; margin-bottom: 4px; font-weight: 700; color: #444; }
        input[type=range] { width: 100%; cursor: pointer; height: 5px; background: #ddd; border-radius: 5px; appearance: none;}
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: #1565c0; border-radius: 50%; cursor: pointer; margin-top: -5px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);}
        
        /* 數字輸入框樣式 */
        input[type=number] { width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; margin-left: 10px; font-weight: bold; color: #333;}
        
        select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 6px; background: #fafafa; font-size: 1em; }
        
        .btn-main { width: 100%; padding: 10px; margin-bottom: 10px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; color: white; font-size: 1em; background: #5c6bc0; }
        .btn-main:hover { background: #3f51b5; }
        .btn-sub { flex: 1; padding: 10px; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: bold; font-size: 0.95em;}
        #btn-start { background: #2e7d32; display: none; } #btn-start:hover { background: #1b5e20; }
        #btn-reset { background: #c62828; } #btn-reset:hover { background: #b71c1c; }
        .paused-active { background: #ff9800 !important; }

        .checkbox-container { display: flex; align-items: center; margin-top: 5px; font-size: 0.9em; color: #6a1b9a; font-weight: bold; background: #f3e5f5; padding: 8px; border-radius: 6px; margin-bottom: 5px;}
        .checkbox-container input { margin-right: 10px; cursor: pointer;}
        .checkbox-container label { margin: 0; cursor: pointer; color: #4a148c; }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9em; border-bottom: 1px dashed #eee;}
        .stat-value { font-family: 'Courier New', monospace; font-weight: bold; color: #d32f2f; }
        
        .alert { padding: 12px; border-radius: 6px; text-align: center; display: none; margin-bottom: 12px; font-weight: bold; color: white; font-size: 0.95em; box-shadow: 0 2px 5px rgba(0,0,0,0.2); line-height: 1.4; }
        .alert-fail { background: #d32f2f; } .alert-ok { background: #2e7d32; } .alert-warn { background: #ff9800; }

        .legend { margin-top: 10px; background: #f8f9fa; padding: 10px; border-radius: 6px; font-size: 0.85em; border: 1px solid #eee; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="ui-panel">
        <div class="panel-header">
            <h2>參數設定</h2>
            <button id="btn-toggle-panel">收起 ▲</button>
        </div>
        
        <div class="panel-content" id="panel-content">
            <div id="top-controls">
                <button id="btn-start" class="btn-sub">開始實驗</button>
                <button id="btn-reset" class="btn-sub">重置</button>
            </div>
            <button id="btn-pause" class="btn-main">暫停 / 繼續 (Pause)</button>
            <div id="alert-box" class="alert alert-fail">警告訊息</div>

            <div class="control-group">
                <label>情境模式</label>
                <select id="scenarioSelect">
                    <option value="flat">1. 平路轉彎 (Friction)</option>
                    <option value="banked">2. 斜坡轉彎 (Banked Turn)</option>
                    <option value="washer">3. 洗衣機滾筒 (Washer)</option>
                    <option value="tether">4. 雙物體繩張力 (Tether)</option>
                </select>
            </div>

            <div class="control-group">
                <label>切線速率 v = <span id="val-v">0</span> m/s</label>
                <div style="display:flex; align-items:center;">
                    <input type="range" id="inp-v" min="0" max="40" step="0.1" value="0" style="flex-grow:1;">
                    <input type="number" id="num-v" min="0" max="40" step="0.1" value="0">
                </div>
            </div>
            
            <div class="control-group" id="grp-r">
                <label>半徑 r = <span id="val-r">40</span> m</label>
                <input type="range" id="inp-r" min="5" max="40" step="1" value="40">
            </div>

            <div class="control-group">
                <label>旋轉質量 m = <span id="val-m">100</span> kg</label>
                <input type="range" id="inp-m" min="10" max="200" step="10" value="100">
            </div>

            <div class="control-group" id="grp-theta" style="display:none;">
                <label>傾斜角 θ = <span id="val-theta">0</span>°</label>
                <div style="display:flex; align-items:center;">
                    <input type="range" id="inp-theta" min="0" max="85" step="1" value="0" style="flex-grow:1;">
                    <input type="number" id="num-theta" min="0" max="85" step="1" value="0">
                </div>
            </div>

            <div id="grp-mode4" style="display:none; border-top: 2px solid #eee; padding-top:10px;">
                <div class="control-group">
                    <label style="color:#c62828;">懸掛質量 M = <span id="val-massM">150</span> kg</label>
                    <input type="range" id="inp-massM" min="10" max="400" step="10" value="150">
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="chk-watchM">
                    <label for="chk-watchM">1. 注視 M (顯示受力)</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="chk-momentum" checked disabled>
                    <label for="chk-momentum" style="color:#666; cursor:default;">2. 角動量守恆 [常駐]</label>
                </div>
                <div class="checkbox-container">
                      <input type="checkbox" id="chk-showL">
                      <label for="chk-showL">3. 顯示角動量 (簡化受力)</label>
                </div>
            </div>

            <hr style="border-color: #eee;">

            <div class="stat-row">
                <span>需求向心力 (Fc):</span>
                <span class="stat-value" id="out-fc">0 N</span>
            </div>
            <div class="stat-row" id="row-tension" style="display:none;">
                <span>懸掛重力 (Mg):</span>
                <span class="stat-value" id="out-tension">0 N</span>
            </div>
            <div class="stat-row">
                <span>正向力 (N):</span>
                <span class="stat-value" id="out-fn">0 N</span>
            </div>

            <div class="legend">
                <div class="legend-item"><div class="color-box" style="background:#ff0000"></div>Fc / T (合力/張力)</div>
                <div class="legend-item"><div class="color-box" style="background:#0066ff"></div>N (正向力)</div>
                <div class="legend-item"><div class="color-box" style="background:#00cc00"></div>mg / Mg (重力)</div>
                <div class="legend-item" id="legend-L" style="display:none;"><div class="color-box" style="background:#9c27b0"></div>L (角動量)</div>
            </div>
        </div>
    </div>

    <div id="eqn-panel">
        <div class="eqn-title">受力分析 (FBD)</div>
        <canvas id="vector-canvas" width="340" height="260"></canvas>
        <div id="eqn-content"></div>
    </div>

    <div id="canvas-container"></div>

<script>
    // --- 全局狀態 ---
    let params = {
        v: 0, r: 40, m: 100, massM: 150, theta: 0, g: 9.8,
        mode: 'flat', mu: 0.5, showL: false, watchM: false
    };

    let state = {
        paused: false, time: 0,
        bankedSlide: 0, bankedFailed: false,
        tetherR: 40, tetherRunning: false, tetherFailed: false,
        washerY: 10, washerFailed: false
    };

    // --- Three.js Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeef1f3);
    scene.fog = new THREE.Fog(0xeef1f3, 50, 500);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    const defaultCamPos = new THREE.Vector3(0, 60, 130);
    camera.position.copy(defaultCamPos);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(30, 80, 30);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- 物件 ---
    const pivotGroup = new THREE.Group(); scene.add(pivotGroup);
    const carWrapper = new THREE.Group(); pivotGroup.add(carWrapper);
    const carMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), new THREE.MeshPhongMaterial({ color: 0xffaa00 }));
    carMesh.castShadow = true; carWrapper.add(carMesh);

    // Angle Helper (Mode 2)
    const angleHelper = new THREE.Mesh(
        new THREE.RingGeometry(6, 6.2, 32, 1, 0, 0), // 初始空
        new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide })
    );
    angleHelper.visible = false;
    carWrapper.add(angleHelper);

    // Tether System
    const hangingMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshPhongMaterial({ color: 0xc62828 }));
    scene.add(hangingMesh);
    const ropeLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 3 }));
    scene.add(ropeLine);
    
    // 軌跡虛線圈 (Mode 4)
    const trajectoryGeo = new THREE.RingGeometry(39.8, 40.2, 64);
    const trajectoryMat = new THREE.MeshBasicMaterial({ color: 0x2196f3, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
    const trajectoryCircle = new THREE.Mesh(trajectoryGeo, trajectoryMat);
    trajectoryCircle.rotation.x = -Math.PI/2; 
    trajectoryCircle.position.y = 0.1;
    trajectoryCircle.visible = false;
    scene.add(trajectoryCircle);

    const trackGroup = new THREE.Group(); scene.add(trackGroup);

    // --- 3D 向量箭頭 ---
    function createArrow(color, name, scale=1) {
        const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(), 1, color, 0.8*scale, 0.5*scale);
        const cvs = document.createElement('canvas'); cvs.width = 256; cvs.height = 128; 
        const ctx = cvs.getContext('2d'); ctx.font = "bold 90px Arial"; ctx.fillStyle = '#'+color.toString(16).padStart(6,'0');
        ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(name, 128, 64);
        const label = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cvs), transparent:true}));
        label.scale.set(8*scale, 4*scale, 1);
        scene.add(arrow); scene.add(label);
        return {arrow, label, update: (pos, dir, len) => {
            if(len<0.1){ arrow.visible=false; label.visible=false; return;}
            arrow.visible=true; label.visible=true;
            arrow.position.copy(pos); arrow.setDirection(dir); arrow.setLength(len);
            label.position.copy(pos).add(dir.clone().multiplyScalar(len + 3*scale));
        }};
    }
    const arrowN = createArrow(0x0066ff, "N");
    const arrowFg = createArrow(0x00cc00, "mg");
    const arrowFc = createArrow(0xff0000, "Fc");
    const arrowL = createArrow(0x9c27b0, "L", 1.0); 
    const arrowFg_M = createArrow(0x00cc00, "Mg", 1.2);
    const arrowT_M = createArrow(0xff0000, "T", 1.2);

    // --- 2D 向量繪圖 ---
    function drawVectorDiagram() {
        const cvs = document.getElementById('vector-canvas');
        const ctx = cvs.getContext('2d');
        const w = cvs.width, h = cvs.height;
        const cx = w/2, cy = h/2 + 20;

        ctx.clearRect(0, 0, w, h);
        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(cx, 10); ctx.lineTo(cx, h-10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10, cy); ctx.lineTo(w-10, cy); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#ffaa00'; ctx.fillRect(cx - 15, cy - 15, 30, 30);
        
        const canvasScale = 0.15;
        const maxVectorLen = 120;

        function drawVec(dx, dy, color, label, isDashed=false) {
            let vX = dx * canvasScale;
            let vY = -dy * canvasScale; 
            
            const len = Math.sqrt(vX*vX + vY*vY);
            if(len < 5) return;

            if (len > maxVectorLen) {
                const ratio = maxVectorLen / len;
                vX *= ratio; vY *= ratio;
            }

            const ex = cx + vX, ey = cy + vY; 
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ex, ey);
            ctx.strokeStyle = color; ctx.lineWidth = 3;
            if(isDashed) ctx.setLineDash([3,3]); else ctx.setLineDash([]);
            ctx.stroke();
            
            const angle = Math.atan2(vY, vX); 
            const headLen = 12;
            ctx.beginPath();
            ctx.moveTo(ex, ey);
            ctx.lineTo(ex - headLen * Math.cos(angle - Math.PI/6), ey - headLen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(ex - headLen * Math.cos(angle + Math.PI/6), ey - headLen * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = color; ctx.fill();
            
            ctx.fillStyle = color; ctx.font = "bold 16px Arial";
            ctx.fillText(label, ex + (vX>0?5:-35), ey + (vY>0?20:-10));
        }

        const scale = 0.5; 
        const Fg = params.m * params.g * scale;
        drawVec(0, -Fg, '#00cc00', 'mg'); 

        if (params.mode === 'flat') {
            drawVec(0, Fg, '#0066ff', 'N'); 
            const f = params.m * params.v * params.v / params.r * scale;
            if(params.v > 0) drawVec(-f, 0, '#ff0000', 'fs (Fc)'); 
        } else if (params.mode === 'banked') {
            const rad = THREE.MathUtils.degToRad(params.theta);
            const N_mag = Fg / Math.cos(rad);
            const Nx = -N_mag * Math.sin(rad); 
            const Ny = N_mag * Math.cos(rad);
            drawVec(Nx, Ny, '#0066ff', 'N'); 
            
            ctx.beginPath(); ctx.arc(cx, cy, 40, -Math.PI/2, -Math.PI/2 - rad, true);
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth=2; ctx.stroke();
            ctx.fillStyle = '#ffd700'; ctx.fillText('θ', cx-10, cy-50);
            
            drawVec(Nx, 0, '#ff0000', 'Fc', true); 
        } else if (params.mode === 'washer') {
            const N = params.m * params.v * params.v / params.r * scale;
            drawVec(-N, 0, '#0066ff', 'N (Fc)'); 
            drawVec(0, Fg, '#aaaaaa', 'fs'); 
        } else if (params.mode === 'tether') {
            const T = params.massM * params.g * scale;
            drawVec(-T, 0, '#ff0000', 'T (Fc)'); 
            drawVec(0, Fg, '#0066ff', 'N'); 
        }
    }

    // --- HTML 數學公式 ---
    function updateEquationPanel() {
        const div = document.getElementById('eqn-content');
        let html = '';
        const fs_html = `<span class="math-var">f</span><span class="math-sub">s</span>`;
        const mg_html = `<span class="math-var">mg</span>`;
        // Flexbox fraction
        const frac = (top, bot) => `<div class="fraction"><span class="numerator">${top}</span><span class="denominator">${bot}</span></div>`;
        const mv2_r = frac(`<span class="math-var">mv</span><sup>2</sup>`, `<span class="math-var">r</span>`);

        if (params.mode === 'flat') {
            html = `<div class="math-row">水平：${fs_html} = ${mv2_r}</div>
                    <div class="math-row">鉛直：<span class="math-var">N</span> = ${mg_html}</div>
                    <div class="note">靜摩擦力 ${fs_html} 指向圓心提供向心力。</div>`;
        } else if (params.mode === 'banked') {
            html = `<div class="math-row">水平：<span class="math-var">N</span> sin<span class="math-var">θ</span> = ${mv2_r}</div>
                    <div class="math-row">鉛直：<span class="math-var">N</span> cos<span class="math-var">θ</span> = ${mg_html}</div>
                    <div class="math-row" style="color:#d32f2f">安全速率：<span class="math-var">v</span> = √<span style="border-top:1px solid"><span class="math-var">rg</span> tan<span class="math-var">θ</span></span></div>`;
        } else if (params.mode === 'washer') {
            html = `<div class="math-row">水平：<span class="math-var">N</span> = ${mv2_r}</div>
                    <div class="math-row">鉛直：${fs_html} = ${mg_html}</div>`;
        } else if (params.mode === 'tether') {
            html = `<div class="math-row">繩張力：<span class="math-var">T</span> = <span class="math-var">Mg</span></div>
                    <div class="math-row">旋轉體：<span class="math-var">T</span> = ${mv2_r}</div>
                    <div class="math-row" style="border-top:1px solid #ddd; padding-top:5px; width:100%"><span class="math-var">Mg</span> = ${mv2_r}</div>`;
        }
        div.innerHTML = html;
    }

    // --- 幾何更新 (無地板) ---
    function updateTrackGeometry() {
        while(trackGroup.children.length > 0) trackGroup.remove(trackGroup.children[0]);
        
        // 根據模式調整材質透明度
        const isBanked = params.mode === 'banked';
        const matRoad = new THREE.MeshPhongMaterial({ 
            color: 0x555555, 
            side: THREE.DoubleSide,
            transparent: isBanked, 
            opacity: isBanked ? 0.5 : 1.0 
        });
        
        const roadWidth = Math.max(8, params.r * 0.4); 
        const inner = params.r - roadWidth/2;
        const outer = params.r + roadWidth/2;

        if (params.mode === 'tether') {
            const tableR = 50; 
            const table = new THREE.Mesh(new THREE.CylinderGeometry(tableR, tableR, 1, 64), new THREE.MeshPhongMaterial({color:0xdddddd}));
            table.position.y = -0.5; trackGroup.add(table);
            const hole = new THREE.Mesh(new THREE.CircleGeometry(2.5, 32), new THREE.MeshBasicMaterial({color:0x111111}));
            hole.rotation.x = -Math.PI/2; hole.position.y = 0.05; trackGroup.add(hole);
            
            // 虛線圈
            trajectoryCircle.visible = true;
            trajectoryCircle.geometry.dispose();
            trajectoryCircle.geometry = new THREE.RingGeometry(params.r - 0.2, params.r + 0.2, 64);
            
        } else if (params.mode === 'washer') {
            trajectoryCircle.visible = false;
            const drumR = outer;
            const drum = new THREE.Mesh(
                new THREE.CylinderGeometry(drumR, drumR, 20, 64, 1, true),
                new THREE.MeshPhongMaterial({ color: 0xaaaaff, opacity: 0.2, transparent: true, side: THREE.DoubleSide })
            );
            drum.position.y = 10; trackGroup.add(drum);
            trackGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(drumR, drumR, 0.5, 64), matRoad));
        } else {
            trajectoryCircle.visible = false;
            const geo = new THREE.RingGeometry(inner, outer, 128, 1);
            if (params.mode === 'banked') {
                const rad = THREE.MathUtils.degToRad(params.theta);
                const pos = geo.attributes.position;
                for (let i=0; i<pos.count; i++) {
                    const d = Math.sqrt(pos.getX(i)**2 + pos.getY(i)**2);
                    const h = (d - params.r) * Math.tan(rad);
                    pos.setZ(i, h);
                }
                geo.computeVertexNormals();
            }
            const road = new THREE.Mesh(geo, matRoad);
            road.rotation.x = -Math.PI/2; road.position.y = 0.02;
            trackGroup.add(road);
        }
        updateEquationPanel();
    }

    function updateTetherVisuals(r) {
        const dropLen = 55 - r;
        hangingMesh.position.set(0, -dropLen, 0);
        
        const vScale = 0.02;
        const MPos = hangingMesh.position.clone();
        
        const hideOtherForces = (params.mode === 'tether' && params.showL);

        if(params.mode === 'tether' && params.watchM && !hideOtherForces) {
            arrowFg_M.update(MPos, new THREE.Vector3(0,-1,0), params.massM*params.g*vScale);
            arrowT_M.update(MPos, new THREE.Vector3(0,1,0), params.massM*params.g*vScale);
        } else {
            arrowFg_M.update(new THREE.Vector3(), new THREE.Vector3(), 0);
            arrowT_M.update(new THREE.Vector3(), new THREE.Vector3(), 0);
        }

        const mPos = new THREE.Vector3(); carMesh.getWorldPosition(mPos);
        ropeLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute([mPos.x,mPos.y,mPos.z, 0,0.5,0, 0,-dropLen,0], 3));
        ropeLine.geometry.attributes.position.needsUpdate = true;
    }

    // --- 動畫核心 ---
    function animate() {
        requestAnimationFrame(animate);
        drawVectorDiagram();
        if (state.paused) { renderer.render(scene, camera); return; }

        const dt = 0.016; let displayR = params.r; let displayV = params.v;

        // 物理邏輯
        if (params.mode === 'tether' && state.tetherRunning) {
            if (state.tetherFailed) {
                 displayR = 2.0; displayV = 0;
            } else {
                const Fc_req = params.m * params.v * params.v / state.tetherR;
                const T_avail = params.massM * params.g;
                const netForce = Fc_req - T_avail; 
                const driftSpeed = netForce * 0.00025; 
                const prevR = state.tetherR; state.tetherR += driftSpeed;

                // 角動量守恆
                if (Math.abs(driftSpeed) > 1e-5 && state.tetherR > 2.0) {
                    const newV = params.v * (prevR / state.tetherR);
                    params.v = Math.min(newV, 80);
                    // 同步兩個輸入框
                    document.getElementById('inp-v').value = params.v;
                    document.getElementById('num-v').value = params.v.toFixed(1);
                    document.getElementById('val-v').innerText = params.v.toFixed(1);
                }

                if (state.tetherR < 2.0) {
                    state.tetherR = 2.0; state.tetherFailed = true;
                    showAlert("實驗失敗：離心力不足，物體被拉入洞口", "fail");
                }
                if (state.tetherR > 40) state.tetherR = 40;
                displayR = state.tetherR;
                document.getElementById('val-r').innerText = displayR.toFixed(1);
                
                // Update dashed circle to follow m
                trajectoryCircle.geometry.dispose();
                trajectoryCircle.geometry = new THREE.RingGeometry(displayR - 0.2, displayR + 0.2, 64);
            }
        }
        else if (params.mode === 'banked' && !state.bankedFailed) {
            const rad = THREE.MathUtils.degToRad(params.theta);
            const v_ideal = Math.sqrt(params.r * params.g * Math.tan(rad));
            const tolerance = 0.2;
            if (params.v > v_ideal + tolerance) {
                state.bankedSlide += 0.2; 
                showAlert(`速度過快！建議減速至 ${v_ideal.toFixed(1)} m/s`, "fail");
            } else if (params.v < v_ideal - tolerance) {
                state.bankedSlide -= 0.2; 
                showAlert(`速度過慢！建議加速至 ${v_ideal.toFixed(1)} m/s`, "fail");
            } else {
                state.bankedSlide = 0; showAlert("完美平衡 (v ≈ " + v_ideal.toFixed(1) + ")", "alert-ok");
            }
            if (Math.abs(state.bankedSlide) > 12) {
                state.bankedFailed = true; state.paused = true;
                document.getElementById('btn-pause').innerText = "已暫停 (請重置)";
            }
        }
        else if (params.mode === 'washer') {
            const N = params.m * params.v * params.v / params.r;
            const f_max = params.mu * N; const fg = params.m * params.g;
            if (f_max < fg && params.v > 0.1) {
                state.washerFailed = true; state.washerY -= 0.15; 
                if(state.washerY < 1.5) {
                    state.washerY = 1.5; params.v = 0;
                    document.getElementById('val-v').innerText = "0";
                }
                showAlert("摩擦力不足，滑落並停止", "fail");
            } else if (!state.washerFailed) {
                state.washerY = 10; hideAlert();
            }
        }

        // 視覺更新
        if (displayV > 0 && displayR > 0) {
            const omega = displayV / displayR; state.time += dt * omega;
        }
        pivotGroup.rotation.y = -state.time;
        
        const currentR_Visual = displayR + (params.mode === 'banked' ? state.bankedSlide * Math.cos(THREE.MathUtils.degToRad(params.theta)) : 0);
        const slideY = (params.mode === 'banked' ? state.bankedSlide * Math.sin(THREE.MathUtils.degToRad(params.theta)) : 0);
        carWrapper.position.set(currentR_Visual, slideY, 0);

        // 姿態與角度標示更新
        angleHelper.visible = false;
        if (params.mode === 'banked') {
            carMesh.position.y = 1.0; 
            carMesh.rotation.z = THREE.MathUtils.degToRad(params.theta);
            
            angleHelper.visible = true; 
            angleHelper.rotation.z = 0; 
            angleHelper.geometry.dispose();
            angleHelper.geometry = new THREE.RingGeometry(5, 5.2, 32, 1, Math.PI/2, THREE.MathUtils.degToRad(params.theta));

        } else if (params.mode === 'washer') {
            carMesh.position.y = state.washerY; carMesh.rotation.z = Math.PI/2;
        } else if (params.mode === 'tether') {
            carMesh.position.y = 1.5; carMesh.rotation.z = 0;
        } else {
            carMesh.position.y = 0.75; carMesh.rotation.z = 0;
        }

        if (params.mode === 'tether') {
            hangingMesh.visible=true; ropeLine.visible=true;
            updateTetherVisuals(displayR);
            if(params.watchM) controls.target.copy(hangingMesh.position); else controls.target.set(0,0,0);
        } else {
            hangingMesh.visible=false; ropeLine.visible=false;
             updateTetherVisuals(displayR);
        }

        const hideOtherForces = (params.mode === 'tether' && params.showL);

        const vScale = 0.02; const mPos = new THREE.Vector3(); carMesh.getWorldPosition(mPos);
        const Fg = params.m * params.g;
        
        arrowFg.update(mPos, new THREE.Vector3(0,-1,0), hideOtherForces ? 0 : Fg*vScale);
        
        const Fc = params.m * displayV * displayV / (displayR || 1);
        const dirIn = new THREE.Vector3().subVectors(new THREE.Vector3(0,mPos.y,0), mPos).normalize();
        
        if (params.mode === 'tether') {
             const T = params.massM * params.g;
             arrowFc.update(mPos, dirIn, T*vScale);
             
             if(params.showL && displayV > 0) {
                 const L_len = Math.min(params.m * displayV * displayR * 0.0005, 25); 
                 arrowL.update(mPos, new THREE.Vector3(0,1,0), L_len);
             } else {
                 arrowL.update(new THREE.Vector3(), new THREE.Vector3(), 0);
             }
        } else {
             arrowFc.update(mPos, dirIn, Fc*vScale);
             arrowL.update(new THREE.Vector3(), new THREE.Vector3(), 0);
        }

        let N_vec = new THREE.Vector3(0,1,0); let N_mag = Fg;
        if(params.mode === 'banked') {
            N_vec.copy(carMesh.up).applyQuaternion(carMesh.getWorldQuaternion(new THREE.Quaternion()));
            const rad = THREE.MathUtils.degToRad(params.theta);
            N_mag = (params.v > 0) ? Fg / Math.cos(rad) : Fg; 
        } else if (params.mode === 'washer') {
            N_vec.copy(dirIn); N_mag = Fc;
        }
        
        arrowN.update(mPos, N_vec, hideOtherForces ? 0 : N_mag*vScale);

        document.getElementById('out-fc').innerText = Fc.toFixed(0)+" N";
        document.getElementById('out-fn').innerText = N_mag.toFixed(0)+" N";
        document.getElementById('out-tension').innerText = (params.massM*params.g).toFixed(0)+" N";

        controls.update(); renderer.render(scene, camera);
    }

    // --- 事件 ---
    function updateParams() {
        params.v = parseFloat(document.getElementById('inp-v').value);
        params.m = parseFloat(document.getElementById('inp-m').value);
        params.massM = parseFloat(document.getElementById('inp-massM').value);
        params.showL = document.getElementById('chk-showL').checked;
        params.watchM = document.getElementById('chk-watchM').checked;
        if(params.mode!=='tether') params.r = parseFloat(document.getElementById('inp-r').value);
        const newTheta = parseFloat(document.getElementById('inp-theta').value);
        if(params.theta!==newTheta) { params.theta=newTheta; updateTrackGeometry(); }
        if(params.mode!=='tether') updateTrackGeometry();

        document.getElementById('val-v').innerText = params.v.toFixed(1);
        document.getElementById('val-r').innerText = params.mode==='tether'?state.tetherR.toFixed(1):params.r;
        document.getElementById('val-m').innerText = params.m;
        document.getElementById('val-theta').innerText = params.theta;
        document.getElementById('val-massM').innerText = params.massM;
    }
    document.querySelectorAll('input').forEach(el=>el.addEventListener('input', updateParams));

    // 新增: 同步角度滑桿與數字輸入框
    const rangeTheta = document.getElementById('inp-theta');
    const numTheta = document.getElementById('num-theta');
    rangeTheta.addEventListener('input', function() { numTheta.value = this.value; });
    numTheta.addEventListener('input', function() {
         let val = parseFloat(this.value);
         if(val > 85) val = 85; if(val < 0) val = 0;
         if(!isNaN(val)) { this.value = val; rangeTheta.value = val; updateParams(); }
    });

    // 新增: 同步速度滑桿與數字輸入框
    const rangeV = document.getElementById('inp-v');
    const numV = document.getElementById('num-v');
    rangeV.addEventListener('input', function() { numV.value = this.value; });
    numV.addEventListener('input', function() {
         let val = parseFloat(this.value);
         let max = parseFloat(rangeV.max);
         if(val > max) val = max; if(val < 0) val = 0;
         if(!isNaN(val)) { this.value = val; rangeV.value = val; updateParams(); }
    });
    
    document.getElementById('scenarioSelect').addEventListener('change', (e)=>{
        params.mode = e.target.value;
        const els = {
            grp4: document.getElementById('grp-mode4'), theta: document.getElementById('grp-theta'),
            tension: document.getElementById('row-tension'), inpR: document.getElementById('inp-r'),
            grpR: document.getElementById('grp-r'), topBtns: document.getElementById('top-controls'),
            legL: document.getElementById('legend-L'), btnStart: document.getElementById('btn-start'), btnReset: document.getElementById('btn-reset'),
            inpV: document.getElementById('inp-v'), numV: document.getElementById('num-v')
        };
        // 重置顯示與預設值
        els.grpR.style.display = 'block'; 
        // 預設速度上限回歸 40
        els.inpV.max = 40; els.numV.max = 40;

        els.grp4.style.display='none'; els.theta.style.display='none'; els.tension.style.display='none';
        els.topBtns.style.display = 'none'; els.legL.style.display = 'none';
        els.btnStart.style.display = 'none'; els.btnReset.innerText = "重置";
        els.inpR.disabled=false; els.grpR.style.opacity=1;
        state.bankedFailed=false; state.bankedSlide=0; state.washerFailed=false; state.tetherFailed=false;
        hideAlert(); document.getElementById('btn-pause').innerText = "暫停 / 繼續"; state.paused=false;

        if(params.mode==='flat'){
            document.getElementById('inp-v').value = 10; document.getElementById('num-v').value = 10;
            document.getElementById('inp-r').value = 20;
        } else if(params.mode==='banked'){
            els.grpR.style.display = 'none';
            els.theta.style.display='block'; els.topBtns.style.display = 'flex'; 
            document.getElementById('inp-r').value = 30; 
            document.getElementById('inp-theta').value = 15; 
            document.getElementById('num-theta').value = 15; 
            document.getElementById('inp-v').value = 8.9; document.getElementById('num-v').value = 8.9;
        } else if(params.mode==='washer'){
            document.getElementById('inp-theta').value=90;
            document.getElementById('inp-v').value=15; document.getElementById('num-v').value=15;
            document.getElementById('inp-r').value=10;
        } else if(params.mode==='tether'){
            els.grp4.style.display='block'; els.tension.style.display='flex'; els.topBtns.style.display = 'flex';
            els.legL.style.display = 'flex'; els.btnStart.style.display = 'inline-block'; els.btnReset.innerText = "重置 (v=0)";
            els.inpR.disabled=true; els.grpR.style.opacity=0.5;
            
            // 模式四: 限制最大速度以節省空間
            els.inpV.max = 25; els.numV.max = 25;
            
            resetTether();
        }
        updateParams(); updateTrackGeometry();
    });

    function resetTether() {
        state.tetherRunning = false; 
        state.tetherFailed = false; 
        state.tetherR = 40; 
        
        document.getElementById('inp-r').value = 40; 
        params.r = 40;                               
        document.getElementById('val-r').innerText = "40.0";
        
        params.v = 0; 
        document.getElementById('inp-v').value = 0; 
        document.getElementById('num-v').value = 0; // 同步數字框
        document.getElementById('val-v').innerText = "0.0";

        updateParams(); 
        hideAlert();
        
        updateTetherVisuals(40);
        if(params.watchM) controls.target.copy(hangingMesh.position); else controls.target.set(0,0,0);
        
        carWrapper.position.set(40, 1.5, 0);
        
        trajectoryCircle.geometry.dispose();
        trajectoryCircle.geometry = new THREE.RingGeometry(39.8, 40.2, 64); 
        trajectoryCircle.visible = true;
    }

    function resetBanked() {
        state.bankedSlide=0; state.bankedFailed=false; state.paused=false;
        document.getElementById('btn-pause').innerText = "暫停 / 繼續"; hideAlert();
    }
    function resetWasher() {
        state.washerY=10; state.washerFailed=false; hideAlert();
    }

    document.getElementById('btn-start').addEventListener('click', ()=>state.tetherRunning=true);
    document.getElementById('btn-reset').addEventListener('click', ()=>{
        if(params.mode === 'tether') resetTether(); 
        else if(params.mode === 'banked') resetBanked();
        else if(params.mode === 'washer') resetWasher();
        else { updateParams(); }
    });
    document.getElementById('btn-pause').addEventListener('click', function(){
        state.paused = !state.paused; this.classList.toggle('paused-active');
    });
    const btnTog = document.getElementById('btn-toggle-panel');
    const panelC = document.getElementById('panel-content');
    btnTog.addEventListener('click', ()=>{
        panelC.classList.toggle('hidden'); btnTog.innerText = panelC.classList.contains('hidden') ? "展開 ▼" : "收起 ▲";
    });
    function showAlert(msg, type){
        const box=document.getElementById('alert-box'); box.innerText=msg; box.style.display='block';
        box.className='alert '+(type==='fail'?'alert-fail':type==='alert-ok'?'alert-ok':'alert-warn');
    }
    function hideAlert(){document.getElementById('alert-box').style.display='none';}

    document.getElementById('inp-v').value = 10; document.getElementById('num-v').value = 10;
    updateParams(); updateTrackGeometry(); animate();

</script>
</body>
</html>